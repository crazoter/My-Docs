(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{85:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return p}));var n=a(2),r=a(6),l=(a(0),a(99)),i={title:"Network"},b={unversionedId:"markdown/network",id:"markdown/network",isDocsHomePage:!1,title:"Network",description:"Inter-domain Routing",source:"@site/docs/markdown/network.md",slug:"/markdown/network",permalink:"/My-Docs/docs/markdown/network",editUrl:"https://github.com/crazoter/My-Docs/edit/master/website/docs/markdown/network.md",version:"current",sidebar:"someSidebar",previous:{title:"Math",permalink:"/My-Docs/docs/markdown/math"},next:{title:"CS4226 Cheatsheet",permalink:"/My-Docs/docs/markdown/CS4226_summary"}},c=[{value:"Inter-domain Routing",id:"inter-domain-routing",children:[]},{value:"Border Gateway Protocol (BGP)",id:"border-gateway-protocol-bgp",children:[]},{value:"BGP router / speaker",id:"bgp-router--speaker",children:[{value:"BGP Prefix Hijacking",id:"bgp-prefix-hijacking",children:[]},{value:"BGP Subprefix Hijacking",id:"bgp-subprefix-hijacking",children:[]},{value:"BGP in practice",id:"bgp-in-practice",children:[]},{value:"Peer 2 Peer",id:"peer-2-peer",children:[]}]},{value:"CDN",id:"cdn",children:[]}],o={rightToc:c};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"inter-domain-routing"},"Inter-domain Routing"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"2 types of routing algos")),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Comparison"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Link State algo"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Distance Vector algo"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(l.b)("strong",{parentName:"td"},"Router knowledge")),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All know full network topology & link cost info"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Only know connected neighbors & link costs (to all nodes)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(l.b)("strong",{parentName:"td"},"Algo type")),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Global / Centralized e.g. Djikstra"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Decentralized, iteratively by exchanging info with neighbours. Only determines next hop")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(l.b)("strong",{parentName:"td"},"Algo impl")),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Open Shortest Path First (OSPF)"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Routing Info Prtcl (RIP)")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Link State Routing Limitations")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"High bandwidth: ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Topology info is flooded (to other routers)"))),Object(l.b)("li",{parentName:"ul"},"Sensitive info released by nodes"),Object(l.b)("li",{parentName:"ul"},"High processing overhead: Everything computed locally by node"),Object(l.b)("li",{parentName:"ul"},"Unit representing distance is not the same for all nodes")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Distance Vector")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Send distance metric per destination "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Adv"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Hide details of topology"),Object(l.b)("li",{parentName:"ul"},"Only next hop determined per node"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Disadv"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Inconsistent units representing distance"),Object(l.b)("li",{parentName:"ul"},"Slow convergence due to counting-to-infinity",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Counting to infinity: (14:00) A - B - C, if link BC is cut, B will still think A can reach C and increment path cost, A will still think B can reach and increment path cost etc")))))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Path Vector")," = Extension of distance vector"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Send entire path for each destination d "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Adv"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Avoid count-to-infinity problem"),Object(l.b)("li",{parentName:"ul"},"Detect and Avoid loops"))),Object(l.b)("li",{parentName:"ul"},"In terms of ASes, average of only 3 hops needed (flattening of the internet as they seek to shorten the path for customers)")),Object(l.b)("h2",{id:"border-gateway-protocol-bgp"},"Border Gateway Protocol (BGP)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Inter-domain routing protocol (Slide 13)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Allows subnet to advertise to rest of Internet"),Object(l.b)("li",{parentName:"ul"},"Allows ASes to determine \u201cgood\u201d routes to other networks"))),Object(l.b)("li",{parentName:"ul"},"Main goals:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Fulfil agreements with other ISPs",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Define who provide transit for what (based on relationship)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Customer-Provider"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Providers"),": Provide transit service to customer"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Customers"),": Pay provider for internet routing",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Types:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},'"',Object(l.b)("strong",{parentName:"li"},"multi-homing"),'" if customers has multiple providers'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Nontransit AS"),": Provider never flows traffic through customer",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"May not need BGP"),": If no need to route traffic, can just use provider's static IP, no need IDR (Slide 36)"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Selective Transit"),": Allows some AS to flow traffic through, others deny"))))))),Object(l.b)("li",{parentName:"ul"},"Peer to peer (P2P)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"2 ASes agree to transit between their customers"),Object(l.b)("li",{parentName:"ul"},"Usually don't pay each other"),Object(l.b)("li",{parentName:"ul"},"Agreement only between the 2 ASes; relationship is not transitive"),Object(l.b)("li",{parentName:"ul"},"Usually confidential"),Object(l.b)("li",{parentName:"ul"},"Usually between 2 big ASes"),Object(l.b)("li",{parentName:"ul"},"Traffic Exchange Ratio should be roughly balanced"),Object(l.b)("li",{parentName:"ul"},"Pros:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Reduce costs"),Object(l.b)("li",{parentName:"ul"},"Improve end-to-end performance"),Object(l.b)("li",{parentName:"ul"},"May be the only way"))),Object(l.b)("li",{parentName:"ul"},"Cons:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"No profit"),Object(l.b)("li",{parentName:"ul"},"Peers are competition"),Object(l.b)("li",{parentName:"ul"},"Peering requires periodic renegotiation"))))),Object(l.b)("li",{parentName:"ul"},"Sibling to sibling",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"ASs belong to same company"),Object(l.b)("li",{parentName:"ul"},"Share everything"))))))),Object(l.b)("li",{parentName:"ul"},"Minimize costs"),Object(l.b)("li",{parentName:"ul"},"Ensure good performance for customers"))),Object(l.b)("li",{parentName:"ul"},"Tiers:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Tier 1 AS / ISP",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Top of the customer-provider hierarchy, only have peers (no upstream)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Don't have to pay anyone"))),Object(l.b)("li",{parentName:"ul"},"P2P with each other to form a full-mesh",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Around 10-12 ASes (AT&T etc)"))),Object(l.b)("li",{parentName:"ul"},"Lower layer",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"National / regional scope"))),Object(l.b)("li",{parentName:"ul"},"Stub ASes",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"usually customers"))),Object(l.b)("li",{parentName:"ul"},"List at CAIDA AS RANK"))))),Object(l.b)("li",{parentName:"ul"},"2 BGP routers (between ASes) exchange messages",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"advertise paths to different destination network prefixes"))),Object(l.b)("li",{parentName:"ul"},"Application layer, TCP port 179",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"exchange all active routes in their routing tables"),Object(l.b)("li",{parentName:"ul"},"exchange incremental updates"))),Object(l.b)("li",{parentName:"ul"},"BGP/IGP model used by ISPs (S15)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"eBGP: Between ASes: exchange reachability info",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Border routers are directly connected by TCP (no IGP)"),Object(l.b)("li",{parentName:"ul"},"ASes advertise their network prefix"),Object(l.b)("li",{parentName:"ul"},"No expiration timer for routes"),Object(l.b)("li",{parentName:"ul"},"All routes through peer become invalid if it goes down"),Object(l.b)("li",{parentName:"ul"},"Message Info:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Types: OPEN (TCP to peer), UPDATE (advertise/withdraw new/old paths), KEEPALIVE (Keep TCP open), NOTIFICATION (correct errors or FIN) (S18-19)"),Object(l.b)("li",{parentName:"ul"},"Attributes",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Well-Known mandatory:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"AS-PATH: All ASes in the path (e.g. AS1 AS24)"),Object(l.b)("li",{parentName:"ul"},'NEXT-HOP: IP addr of the first router in the next very next AS "next-hop-AS"'))))),Object(l.b)("li",{parentName:"ul"},"Prefix (IP prefix (network mask e.g. 138.16.64/22) of the AS)"),Object(l.b)("li",{parentName:"ul"},"Route: Contains Prefix + attribute"))),Object(l.b)("li",{parentName:"ul"},"BGP Routing & Updating the routing table (hot potato routing)",Object(l.b)("ol",{parentName:"li"},Object(l.b)("li",{parentName:"ol"},"Init: Router learns of prefix from BGP route adverts from iBGPs"),Object(l.b)("li",{parentName:"ol"},"eBGP level: Use shortest AS-PATH"),Object(l.b)("li",{parentName:"ol"},"iBGP level: Find shortest path using OSPF to NEXT-HOP based on chosen AS-PATH"),Object(l.b)("li",{parentName:"ol"},"Updating the forwarding table: Identify port along OSPF shortest path, Add prefix-port entry to forwarding table (e.g. 138.16.64/22, port 4)"))))),Object(l.b)("li",{parentName:"ul"},"iBGP: BGP inside the AS: ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"propagrate reachability info so that other border routers will know (and can exchange)"),Object(l.b)("li",{parentName:"ul"},"Don't have to be directly connected (can use IGP)"),Object(l.b)("li",{parentName:"ul"},"But they must be (logically) fully meshed",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Each pass on prefixes they learn from outside AS"),Object(l.b)("li",{parentName:"ul"},"Do not pass on prefixes learnt from other iBGP speakers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Info not repeated, reduce overhead, scalable"))))))),Object(l.b)("li",{parentName:"ul"},"Interior Gateway Protocol (IGP): The normal network routing")))),Object(l.b)("h2",{id:"bgp-router--speaker"},"BGP router / speaker"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"BGP is policy-based",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Import policy: Filter unwanted routes from neighbour",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Rank customer routes over peer routes"),Object(l.b)("li",{parentName:"ul"},"manipulate attributes to influence path selection for neighbors"))),Object(l.b)("li",{parentName:"ul"},"Export policy: Filter routes you don't want to tell your neighbor",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Dual-homed: attached to 2 networks"),Object(l.b)("li",{parentName:"ul"},"e.g. don't want your neighbours to know and use the route"),Object(l.b)("li",{parentName:"ul"},"e.g. Customer-Provider relationship:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Customer wouldn't want to announce route to its peers (it don't want anything routing traffic through it)"),Object(l.b)("li",{parentName:"ul"},"Providers advertises with everyone"))),Object(l.b)("li",{parentName:"ul"},"e.g. P2P:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Don't want peers to route stuff through them to another peer:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"AS exports only customer routes to a peer"),Object(l.b)("li",{parentName:"ul"},"AS exports a peer's routes only to its customers"))))))))),Object(l.b)("li",{parentName:"ul"},"A routing entry:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Route = prefix + attr + NLRI + (Path attr)"))),Object(l.b)("li",{parentName:"ul"},"What to do with all the inbound UPDATE messages?"),Object(l.b)("li",{parentName:"ul"},"Build a db: Routing Information Base (RIBs)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"RIBs = Adj-RIBs-In + Loc-RIB + Adj-RIBs-Out"),Object(l.b)("li",{parentName:"ul"},"Adj-RIBs-In: incoming routing info (inbound UPDATE)"),Object(l.b)("li",{parentName:"ul"},"Loc-RIB: selected local routes by router"),Object(l.b)("li",{parentName:"ul"},"Adj-RIBs-Out: selected for advertisement to peers")))),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"Apply ",Object(l.b)("strong",{parentName:"li"},"Import Policies")," on Inbound UPDATE"),Object(l.b)("li",{parentName:"ol"},"Select best route from Adj-RIBs-In and pass to Loc-RIB",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"You can choose any policy but this is the recommended process:")),Object(l.b)("ol",Object(n.a)({parentName:"li"},{start:2}),Object(l.b)("li",{parentName:"ol"},"Highest degree of LOCAL_PREF (or the only route to the destination), then tie break:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"LOCAL_PREF: 4-byte unit (default 100) for BGP to indicate route preference. ",Object(l.b)("em",{parentName:"li"},"This is not forwarded."),". Larger better")),Object(l.b)("ol",{parentName:"li"},Object(l.b)("li",{parentName:"ol"},"Smallest ","#"," of ASs in the AS_PATH"),Object(l.b)("li",{parentName:"ol"},"Lowest origin ","#"," in ORIGIN"),Object(l.b)("li",{parentName:"ol"},"Most preferred MULTI_EXIT_DISC (smaller better)"),Object(l.b)("li",{parentName:"ol"},"Routes from eBGP are preferred over iBGP"),Object(l.b)("li",{parentName:"ol"},"Lower interior cost based on NEXT_HOP"),Object(l.b)("li",{parentName:"ol"},"COMMUNITY: for influencing neighbor's neighbors"))))),Object(l.b)("li",{parentName:"ol"},"Install best route as forwarding entries in IP Forwarding Table"),Object(l.b)("li",{parentName:"ol"},"Apply export policies to Adj-RIB-Out",Object(l.b)("ol",{parentName:"li"},Object(l.b)("li",{parentName:"ol"},"Propagate Inbound UPDATE as Outbound UPDATE to other BGP routers")))),Object(l.b)("h3",{id:"bgp-prefix-hijacking"},"BGP Prefix Hijacking"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"2 shae the same prefix"),Object(l.b)("li",{parentName:"ul"},"Blackhole: data traffic discarded"),Object(l.b)("li",{parentName:"ul"},"Spoofing: Data traffic inspected and redirected",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Impersonation")))),Object(l.b)("h3",{id:"bgp-subprefix-hijacking"},"BGP Subprefix Hijacking"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"12.3.158.0/24 and 12.34.0.0/16",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Longer prefix matching will result in all traffic routed to 12.3.158.0/24"),Object(l.b)("li",{parentName:"ul"},"Can visualize with BGPlay"),Object(l.b)("li",{parentName:"ul"},"Can prevent with anomaly detection")))),Object(l.b)("h3",{id:"bgp-in-practice"},"BGP in practice"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Preference (attr)"),Object(l.b)("li",{parentName:"ul"},"Filtering (inbound/outbound filter)"),Object(l.b)("li",{parentName:"ul"},"Tagging (COMMUNITY attr)"),Object(l.b)("li",{parentName:"ul"},"Applications",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"relations",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"influence process"),Object(l.b)("li",{parentName:"ul"},"control route export"))),Object(l.b)("li",{parentName:"ul"},"traffic engineering",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"inbound"),Object(l.b)("li",{parentName:"ul"},"outbound"),Object(l.b)("li",{parentName:"ul"},"remote control ")))))),Object(l.b)("h3",{id:"peer-2-peer"},"Peer 2 Peer"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Client/server = assymetric",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Extension: iteratively/recursively delegate other servers to do task ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. like DNS, a tree structure"))))),Object(l.b)("li",{parentName:"ul"},"Pure P2P",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"No central entity"),Object(l.b)("li",{parentName:"ul"},"All entities directly communicate"),Object(l.b)("li",{parentName:"ul"},"No structure; flat architecture"),Object(l.b)("li",{parentName:"ul"},"Unreliable; how to stay connected or lookup?"))),Object(l.b)("li",{parentName:"ul"},"Napster",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Central index server",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"People register with this server"),Object(l.b)("li",{parentName:"ul"},"Central server knows all peers and files in network"),Object(l.b)("li",{parentName:"ul"},"Search peers by keyword",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Delegation; delegate downloading to P2P"))),Object(l.b)("li",{parentName:"ul"},"Pros:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Single server: consistent view of network"),Object(l.b)("li",{parentName:"ul"},"Fast and efficient searching"),Object(l.b)("li",{parentName:"ul"},"Guarantee correct search results"))),Object(l.b)("li",{parentName:"ul"},"Cons",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Single point of failure"),Object(l.b)("li",{parentName:"ul"},"Large computation to handle queires"),Object(l.b)("li",{parentName:"ul"},"Downloading from a single peer only"),Object(l.b)("li",{parentName:"ul"},"Unreliable content"),Object(l.b)("li",{parentName:"ul"},"Vulnerable to attacks"),Object(l.b)("li",{parentName:"ul"},"Copyright issues"))))))),Object(l.b)("li",{parentName:"ul"},"Gnutella",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Only peers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"People register by connecting to another active peer",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Switch topology",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Queries are flooded in the network"),Object(l.b)("li",{parentName:"ul"},"Once joined, they learn about others and learn topology"))),Object(l.b)("li",{parentName:"ul"},"Download directly from peer"))),Object(l.b)("li",{parentName:"ul"},"Pros",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Fully distributed"),Object(l.b)("li",{parentName:"ul"},"Open protocol"),Object(l.b)("li",{parentName:"ul"},"Robust against node failures"),Object(l.b)("li",{parentName:"ul"},"Robust to DOS"))),Object(l.b)("li",{parentName:"ul"},"Cons",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Inefficient queries flooding"),Object(l.b)("li",{parentName:"ul"},"Poor network management: Nodes need to keep probing "))))))),Object(l.b)("li",{parentName:"ul"},"KaZaA",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"2 types of nodes",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Ordinary Node (ON): peer"),Object(l.b)("li",{parentName:"ul"},"Supernode (SN): peer with more resources & responsibilities",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Promoted from ON if it has enough resources (bandwidth & uptime)"),Object(l.b)("li",{parentName:"ul"},"Promotion is consensual with user"),Object(l.b)("li",{parentName:"ul"},"Avg lifetime of 2.5 hours"),Object(l.b)("li",{parentName:"ul"},"Don't cache info from disconnected ON"))))),Object(l.b)("li",{parentName:"ul"},"SN - ON : One - Many relationship",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"ON only connected to one SN (and nothing else) which acts as their gateway"))),Object(l.b)("li",{parentName:"ul"},"SN acts as local sever for all connected ON"),Object(l.b)("li",{parentName:"ul"},"SN do not form a complete mesh"))),Object(l.b)("li",{parentName:"ul"},"Skype",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Similar infrastructure to KaZaA"),Object(l.b)("li",{parentName:"ul"},"P2P with proprietary application-layer encryption"),Object(l.b)("li",{parentName:"ul"},"ON and SN infrastrcuture; distributed SNs help map usernames to IP addresses"),Object(l.b)("li",{parentName:"ul"},"Problem of NAT",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"NAT prevents peers outside of network to directly connect"),Object(l.b)("li",{parentName:"ul"},"SNs are used to keep track of relay nodes"),Object(l.b)("li",{parentName:"ul"},"Relay nodes used to handle NATs"))))),Object(l.b)("li",{parentName:"ul"},"BitTorrent",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"A network (swarm) to distribute a file",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1 main sever (seed) has the original copy broken into 256KB chunks"),Object(l.b)("li",{parentName:"ul"},"Seed starts tracker server",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"tracker keeps track of seeds and peers in the network (swarm)"))),Object(l.b)("li",{parentName:"ul"},"Seed creates torrent-file (metadata on chunks) and hosts it somewhere",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"checksums"))),Object(l.b)("li",{parentName:"ul"},"Client obtains torrent-file"),Object(l.b)("li",{parentName:"ul"},"Client contacts tracker and connects to peers"),Object(l.b)("li",{parentName:"ul"},"Client downloads/exchange data with peers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Downloading chunks from neighbors: rarest chunk first"),Object(l.b)("li",{parentName:"ul"},"Uploading chunks to neighbors: ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Send to top 4 neighbors that sends her chunks at the highest rate every 10s"),Object(l.b)("li",{parentName:"ul"},"Send to random peer every 30s"))))))),Object(l.b)("li",{parentName:"ul"},"Pro",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},'Can send ".torrent" link which always refer to same file'))),Object(l.b)("li",{parentName:"ul"},"Con",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Hard to identify and find particular files"))))),Object(l.b)("li",{parentName:"ul"},"P2P lookup services",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Searching VS Addressing")),Object(l.b)("li",{parentName:"ul"},"How network is constructed",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Unstructured"),": cannot use addressing",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"But peers can join anyone and objects can be stored anywhere"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Structured"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Structured to define object locations"),Object(l.b)("li",{parentName:"ul"},"Allow deterministic routing & addressing"),Object(l.b)("li",{parentName:"ul"},"e.g. Key-value pairs, hashtables"),Object(l.b)("li",{parentName:"ul"},"Massive index: Create a ",Object(l.b)("strong",{parentName:"li"},"distributed hash table"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Every node handles multiple buckets (change as nodes join and leave)"),Object(l.b)("li",{parentName:"ul"},"Nodes communicate with each other to maintain table"))))))),Object(l.b)("li",{parentName:"ul"},"How objectives are placed"),Object(l.b)("li",{parentName:"ul"},"How efficient objects can be found"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Addressing"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Uniquely ID objects and maintain indexing structure"))),Object(l.b)("li",{parentName:"ul"},"Searching",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Need to make objects searchable"))))),Object(l.b)("li",{parentName:"ul"},"Distributed Hashtable",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Many solutions",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Differences below: How they design the address space and routing strategy"))),Object(l.b)("li",{parentName:"ul"},"Chord",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"You have nodes and you have objects",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"SHA-1 Hash both of them",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Node ID: Hash Node's IP addr"),Object(l.b)("li",{parentName:"ul"},"Obj ID:  Hash Object's name"))))),Object(l.b)("li",{parentName:"ul"},"Store Node IDs in circular linked list",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Each node in array keeps track of predecessor and successor in circular array (clockwise)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"To store an object"),": Hash the object to get its object ID, then step clock-wise from ID until you find a node (i.e. ",Object(l.b)("strong",{parentName:"li"},"immediate successor"),"). That node stores the object"),Object(l.b)("li",{parentName:"ul"},"Circular linked list: O(n) time to for a node to access an object in another node",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Finger table"),": every node has shortcut links to non-neighbor nodes",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"At most m shortcuts"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Interval"),": ith finger at least ",Object(l.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(l.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(l.b)("semantics",{parentName:"math"},Object(l.b)("mrow",{parentName:"semantics"},Object(l.b)("msup",{parentName:"mrow"},Object(l.b)("mn",{parentName:"msup"},"2"),Object(l.b)("mrow",{parentName:"msup"},Object(l.b)("mi",{parentName:"mrow"},"i"),Object(l.b)("mo",{parentName:"mrow"},"\u2212"),Object(l.b)("mn",{parentName:"mrow"},"1")))),Object(l.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"2^{i-1}")))),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.824664em",verticalAlign:"0em"}})),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"2"),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.824664em"}}),Object(l.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathnormal mtight"}),"i"),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mbin mtight"}),"\u2212"),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"1")))))))))))))," apart ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1st:1, 2nd:2, 3rd:4, 4th:8..."),Object(l.b)("li",{parentName:"ul"},"Defined as [start, end)"),Object(l.b)("li",{parentName:"ul"},"Exponential until it loops back O(log(n))"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Start"),": starting node of the interval (assuming all node IDs are occupied)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Node"),": The actual node used. If there is no node with that node ID, finger points to its immediate successor; however, the interval definition is not affected; this variable tracks that",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"i.e. if [4,6) but shifted to 5, it's still defined as [4,6) and next interval is still 4 spaces"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"When a node leaves"),": ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"All nodes periodically ping successors"),Object(l.b)("li",{parentName:"ul"},"The predecessor will detect it and change its immediate sucessor"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Efficiency"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Search: O(log(n))"),Object(l.b)("li",{parentName:"ul"},"Responsibility N nodes and K objects: O(K/N) objects per node"),Object(l.b)("li",{parentName:"ul"},"Node joining / leaving: O(logN x logN) messages to:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"re-establish routing and finger tables"),Object(l.b)("li",{parentName:"ul"},"initialize finger tables for new node"))),Object(l.b)("li",{parentName:"ul"}))))))))))),Object(l.b)("li",{parentName:"ul"},"CAN",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Think of Chord as a 1 dimensional donut (torus)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1 dimensional donut: predecessor and successor"))),Object(l.b)("li",{parentName:"ul"},"CAN: d-dimensional donut (torus)"),Object(l.b)("li",{parentName:"ul"},"Doesn't use finger tables, can just use neighbors (since it's d-dimensional)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the stuff in the slides is 2D; neighbors can go up down left right.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"When a new node joins:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Cut area of responsibility by cutting vertically before cutting horizontally"))),Object(l.b)("li",{parentName:"ul"},"Object IDs are coordinates"))),Object(l.b)("li",{parentName:"ul"},"Slide 64: state refers to information maintained per node"),Object(l.b)("li",{parentName:"ul"},"Avg path length: since we know predecessor and successor, we can cut the circular path in half and take the shorter path")))))))),Object(l.b)("h2",{id:"cdn"},"CDN"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Traffic has to go through internet (middle-mile) which can be congested",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Distance between user and server negatively affects latency, throughput"),Object(l.b)("li",{parentName:"ul"},"Solutions: connect to a machine closer to client",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Big data center CDNs"),Object(l.b)("li",{parentName:"ul"},"Highly distributed CDNs"),Object(l.b)("li",{parentName:"ul"},"P2P")))))),Object(l.b)("details",null,Object(l.b)("summary",null,"Template"),Object(l.b)("p",null)))}p.isMDXComponent=!0},99:function(e,t,a){"use strict";a.d(t,"a",(function(){return s})),a.d(t,"b",(function(){return O}));var n=a(0),r=a.n(n);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),p=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},s=function(e){var t=p(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,i=e.parentName,o=c(e,["components","mdxType","originalType","parentName"]),s=p(a),m=n,O=s["".concat(i,".").concat(m)]||s[m]||u[m]||l;return a?r.a.createElement(O,b(b({ref:t},o),{},{components:a})):r.a.createElement(O,b({ref:t},o))}));function O(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=m;var b={};for(var c in t)hasOwnProperty.call(t,c)&&(b[c]=t[c]);b.originalType=e,b.mdxType="string"==typeof e?e:n,i[1]=b;for(var o=2;o<l;o++)i[o]=a[o];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);
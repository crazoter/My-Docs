(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{104:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return O}));var n=a(0),r=a.n(n);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),s=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},p=function(e){var t=s(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,i=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=s(a),u=n,O=p["".concat(i,".").concat(u)]||p[u]||m[u]||l;return a?r.a.createElement(O,b(b({ref:t},c),{},{components:a})):r.a.createElement(O,b({ref:t},c))}));function O(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=u;var b={};for(var o in t)hasOwnProperty.call(t,o)&&(b[o]=t[o]);b.originalType=e,b.mdxType="string"==typeof e?e:n,i[1]=b;for(var c=2;c<l;c++)i[c]=a[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"},90:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return o})),a.d(t,"default",(function(){return s}));var n=a(2),r=a(6),l=(a(0),a(104)),i={title:"Network"},b={unversionedId:"markdown/network",id:"markdown/network",isDocsHomePage:!1,title:"Network",description:"Inter-domain Routing",source:"@site/docs/markdown/network.md",slug:"/markdown/network",permalink:"/My-Docs/docs/markdown/network",editUrl:"https://github.com/crazoter/My-Docs/edit/master/website/docs/markdown/network.md",version:"current",sidebar:"someSidebar",previous:{title:"Math",permalink:"/My-Docs/docs/markdown/math"},next:{title:"CS4226 Cheatsheet",permalink:"/My-Docs/docs/markdown/CS4226_summary"}},o=[{value:"Inter-domain Routing",id:"inter-domain-routing",children:[]},{value:"Border Gateway Protocol (BGP)",id:"border-gateway-protocol-bgp",children:[{value:"BGP Prefix Hijacking (S69)",id:"bgp-prefix-hijacking-s69",children:[]},{value:"BGP Subprefix Hijacking (S70)",id:"bgp-subprefix-hijacking-s70",children:[]},{value:"BGP in practice",id:"bgp-in-practice",children:[]},{value:"Peer 2 Peer",id:"peer-2-peer",children:[]}]},{value:"P2P lookup services",id:"p2p-lookup-services",children:[]},{value:"CDN",id:"cdn",children:[]}],c={rightToc:o};function s(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"inter-domain-routing"},"Inter-domain Routing"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"2 types of routing algos")),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Comparison"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Link State algo"),Object(l.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Distance Vector algo"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(l.b)("strong",{parentName:"td"},"Router knowledge")),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"All know full network topology & link cost info"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Only know connected neighbors & link costs (to all nodes)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(l.b)("strong",{parentName:"td"},"Algo type")),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Global / Centralized e.g. Djikstra"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Decentralized, iteratively by exchanging info with neighbours. Only determines next hop")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(l.b)("strong",{parentName:"td"},"Algo impl")),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Open Shortest Path First (OSPF)"),Object(l.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Routing Info Prtcl (RIP)")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Link State Routing Limitations")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"High bandwidth: ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Topology info is flooded (to other routers)"))),Object(l.b)("li",{parentName:"ul"},"Sensitive info released by nodes"),Object(l.b)("li",{parentName:"ul"},"High processing overhead: Everything computed locally by node"),Object(l.b)("li",{parentName:"ul"},"Unit representing distance is not the same for all nodes")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Distance Vector")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Send distance metric per destination "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Adv"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Hide details of topology"),Object(l.b)("li",{parentName:"ul"},"Only next hop determined per node"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Disadv"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Inconsistent units representing distance"),Object(l.b)("li",{parentName:"ul"},"Slow convergence due to counting-to-infinity",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Counting to infinity: (14:00) A - B - C, if link BC is cut, B will still think A can reach C and increment path cost, A will still think B can reach and increment path cost etc")))))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Path Vector")," = Extension of distance vector"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Send entire path for each destination d "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Adv"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Avoid count-to-infinity problem"),Object(l.b)("li",{parentName:"ul"},"Detect and Avoid loops"))),Object(l.b)("li",{parentName:"ul"},"In terms of ASes, average of only 3 hops needed (flattening of the internet as they seek to shorten the path for customers)")),Object(l.b)("h2",{id:"border-gateway-protocol-bgp"},"Border Gateway Protocol (BGP)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Inter-domain routing protocol (Slide 13)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Allows subnet to advertise to rest of Internet"),Object(l.b)("li",{parentName:"ul"},"Allows ASes to determine \u201cgood\u201d routes to other networks"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Main goals:"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1) Fulfil agreements with other ISPs",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Define who provide transit for what (based on ",Object(l.b)("strong",{parentName:"li"},"relationship"),")",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Customer-Provider Relationship"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"AS defined as ",Object(l.b)("strong",{parentName:"li"},"Provider"),": Provide transit service to customer"),Object(l.b)("li",{parentName:"ul"},"AS defined as ",Object(l.b)("strong",{parentName:"li"},"Customer"),": Pay provider for internet routing",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Types:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},'"',Object(l.b)("strong",{parentName:"li"},"multi-homing"),'" if customers has multiple providers. ',Object(l.b)("strong",{parentName:"li"},"dual-homed")," if has 2."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Nontransit AS"),": Provider never flows traffic through customer.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"May not need BGP"),": If no need to route traffic, can just use provider's static IP, no need IDR (Slide 36)"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Selective Transit"),": Allows some AS to flow traffic through, others deny. ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Unless defined, customers never route traffic through themselves"))))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"AS Peer to peer Relationship"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"AS defined as ",Object(l.b)("strong",{parentName:"li"},"Peering")),Object(l.b)("li",{parentName:"ul"},"2 (big) ASes agree to transit between their customers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Only between the 2 ASes; relationship is not transitive"))),Object(l.b)("li",{parentName:"ul"},"Usually don't pay each other"),Object(l.b)("li",{parentName:"ul"},"Usually confidential"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Traffic Exchange Ratio")," should be roughly balanced"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Pros"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Reduce costs"),Object(l.b)("li",{parentName:"ul"},"Improve end-to-end performance"),Object(l.b)("li",{parentName:"ul"},"May be the only way"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Cons"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"No profit"),Object(l.b)("li",{parentName:"ul"},"Peers are competition"),Object(l.b)("li",{parentName:"ul"},"Peering requires periodic renegotiation"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Sibling to Sibling Relationship"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"AS-AS belong to same company"),Object(l.b)("li",{parentName:"ul"},"Share everything"))))))),Object(l.b)("li",{parentName:"ul"},"2) Minimize costs"),Object(l.b)("li",{parentName:"ul"},"3) Ensure good performance for customers"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Tiers"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Tier 1 AS / ISP"),": Top of the customer-provider hierarchy",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"only have peers (no upstream)"),Object(l.b)("li",{parentName:"ul"},"Don't have to pay anyone"),Object(l.b)("li",{parentName:"ul"},"P2P with other T1s to form a full-mesh",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Around 10-12 ASes (AT&T etc)"))),Object(l.b)("li",{parentName:"ul"},"Lower layer: ",Object(l.b)("strong",{parentName:"li"},"National / regional scope")),Object(l.b)("li",{parentName:"ul"},"Stub ASes: ",Object(l.b)("strong",{parentName:"li"},"Customers")),Object(l.b)("li",{parentName:"ul"},"List at CAIDA AS RANK"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"BGP Implementation"),": 2 BGP routers (between ASes) exchange messages",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Depends on policy of AS (Slide 57)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Import policy"),": Don't record prefixes that you don't want your AS to help route",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Rank customer routes over peer routes"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Export policy"),": Don't advert routes you don't want neighbour ASes to use",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Providers advertises with everyone it services"),Object(l.b)("li",{parentName:"ul"},"e.g. if AS is Customer in Customer-Provider relationship:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Customer don't want route traffic through itself",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Won't announce route to its peers"))))),Object(l.b)("li",{parentName:"ul"},"e.g. P2P:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Don't want peers to route stuff through them to another peer:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"AS exports only customer routes to a peer"),Object(l.b)("li",{parentName:"ul"},"AS exports a peer's routes only to its customers"))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Manipulate route preferences"),": Artificially make routes look longer / shorter to make external ASes prefer certain routes"))),Object(l.b)("li",{parentName:"ul"},"Application layer, TCP port 179"),Object(l.b)("li",{parentName:"ul"},"Advertise paths to different destination network prefixes"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Procedure"),": Slide 14"),Object(l.b)("li",{parentName:"ul"},"1) BGP routers (2 AS, 1 in each AS) start session on TCP port 179, by sending ",Object(l.b)("strong",{parentName:"li"},"OPEN")," BGP msgs and ACK by ",Object(l.b)("strong",{parentName:"li"},"KEEPALIVE"),".",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1.1) BGP Router also learns of prefix-port mappings from BGP route adverts from iBGPs"))),Object(l.b)("li",{parentName:"ul"},"2) Exchange all active routes in their routing tables by sending ",Object(l.b)("strong",{parentName:"li"},"UPDATE")," BGP msgs"),Object(l.b)("li",{parentName:"ul"},"3) Exchange incremental updates using ",Object(l.b)("strong",{parentName:"li"},"UPDATE"),", and correct errors using ",Object(l.b)("strong",{parentName:"li"},"NOTIFICATION"),".",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"UPDATE message format"),": Slide 19",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Marker (16b), Length (2b), Type (1b), Withdrawn Routes Length (2b), Withdrawn Routes  (variable), Path Attribute Length (2b), ",Object(l.b)("strong",{parentName:"li"},"Path Attributes"),"  (variable), ",Object(l.b)("strong",{parentName:"li"},"Network Layer Reachability Information (NLRI)"),"  (variable)"),Object(l.b)("li",{parentName:"ul"},"Can withdraw many routes in 1 message"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"NLRI"),": Reachable IP prefixes (IP subnet mask) using route defined by ",Object(l.b)("strong",{parentName:"li"},"Path Attribute"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. Prefix: 138.16.64/22"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"A route consists of NLRI (prefixes) + path (defined by path attr)")),Object(l.b)("li",{parentName:"ul"},"Thus, can only advertise 1 route per message"),Object(l.b)("li",{parentName:"ul"},"Defining Path Attributes: Slide 21",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"well-known mandatory"),": must be included if defining new route, and must be forwarded (S23)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"ORIGIN"),": Origin of prefix"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"AS-PATH"),": Sequence of ASes in route (e.g. AS 79, AS 11)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"NEXT-HOP"),": IP Addr of BGP router in next-hop AS"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"well-known discretionary")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"optional transitive")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"optional non-transitive"),": only to adjacent AS"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"No timeout on routes"),": Invalid routes are removed with ",Object(l.b)("strong",{parentName:"li"},"UPDATE")," message"))),Object(l.b)("li",{parentName:"ul"},"3.1) ",Object(l.b)("strong",{parentName:"li"},"If multiple routes to same prefix"),": Tie-break BGP routes by:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1) Shortest AS-PATH"),Object(l.b)("li",{parentName:"ul"},"2) ",Object(l.b)("strong",{parentName:"li"},"Hot Potato Routing"),": Get it out of AS ASAP (S30)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Use OSPF to choose closest NEXT-HOP AS router"))))),Object(l.b)("li",{parentName:"ul"},"3.2) Update RIB (Slide 56) and forwarding table (Slide 31) using inbound UPDATEs",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Build a database: Routing Information Base (RIBs)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Adj-RIBs-In: unprocessed inbound UPDATEs",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Between Adj-RIB-In and Loc-RIB: Route selection. Tie break by (Slide 65):",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1) Largest LOCAL_PREF: 4-byte unit (default 100) for BGP to indicate route preference. ",Object(l.b)("em",{parentName:"li"},"This is not forwarded.")),Object(l.b)("li",{parentName:"ul"},"2) Smallest AS_PATH"),Object(l.b)("li",{parentName:"ul"},"3) Smallest ORIGIN number"),Object(l.b)("li",{parentName:"ul"},"4) Smallest MULTI_EXIT_DISC (optional non-transitive). In use if peer AS has many BGP entry-points."),Object(l.b)("li",{parentName:"ul"},"5) Routes from eBGP are preferred over iBGP"),Object(l.b)("li",{parentName:"ul"},"6) Smallest interior cost based on NEXT_HOP"),Object(l.b)("li",{parentName:"ul"},"7) COMMUNITY: for influencing neighbor's neighbors, used to group destinations"))))),Object(l.b)("li",{parentName:"ul"},"Loc-RIB: selected best routes."),Object(l.b)("li",{parentName:"ul"},"Adj-RIBs-Out: selected routes for advertisement to peers ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"propagate inbound UPDATE as outbound UPDATE to peers"))))),Object(l.b)("li",{parentName:"ul"},"Maintain forwarding table of prefix-port entries (e.g. 138.16.64/22, port 4)"))),Object(l.b)("li",{parentName:"ul"},"4) Repeat 3 forever. Close connection with ",Object(l.b)("strong",{parentName:"li"},"NOTIFICATION")," BGP msg.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Connection down:")," Invalidate all routes through disconnected peer"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"BGP/IGP model used by ISPs")," (Slide 15)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Types of BGP: eBGP and iBGP"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"exterior BGP peering (eBGP): Between ASes")," Slide 16 ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"exchange reachability info between ASes"),Object(l.b)("li",{parentName:"ul"},"Directly connected"),Object(l.b)("li",{parentName:"ul"},"ASes advertise their network prefix"),Object(l.b)("li",{parentName:"ul"},"No expiration timer for routes"),Object(l.b)("li",{parentName:"ul"},"All routes through peer become invalid if it goes down"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"interior BGP peering (iBGP): Within AS"),": Slide 17",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Propagate reachability info to other border routers within AS"),Object(l.b)("li",{parentName:"ul"},"Don't have to be directly connected"),Object(l.b)("li",{parentName:"ul"},"MUST be (logically) fully meshed",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Each iBGP router pass on prefixes they learn from the other AS"),Object(l.b)("li",{parentName:"ul"},"Does not pass on prefixes learnt from other iBGP speakers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Info not repeated, reduce overhead, scalable"))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Interior Gateway Protocol (IGP)"),": The normal network routing")))),Object(l.b)("h3",{id:"bgp-prefix-hijacking-s69"},"BGP Prefix Hijacking (S69)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"2 ASes share the same prefix"),Object(l.b)("li",{parentName:"ul"},"Some traffic lost to fake prefix holder:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Blackhole"),": data traffic discarded"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Spoofing / Impersonation"),": Data traffic inspected and redirected")))),Object(l.b)("h3",{id:"bgp-subprefix-hijacking-s70"},"BGP Subprefix Hijacking (S70)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Exploit of ",Object(l.b)("strong",{parentName:"li"},"Longer prefix matching")),Object(l.b)("li",{parentName:"ul"},"1 AS with shorter (more general) prefix hijacked by longer (more specific) prefix",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. 12.34.0.0/16 hijacked by 12.3.158.0/24",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"All traffic routed to 12.3.158.0/24"))),Object(l.b)("li",{parentName:"ul"},"Can visualize with BGPlay"),Object(l.b)("li",{parentName:"ul"},"Can prevent with anomaly detection, checking prefix ownership")))),Object(l.b)("h3",{id:"bgp-in-practice"},"BGP in practice"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Preference (attr)"),Object(l.b)("li",{parentName:"ul"},"Filtering (inbound/outbound filter)"),Object(l.b)("li",{parentName:"ul"},"Tagging (COMMUNITY attr)"),Object(l.b)("li",{parentName:"ul"},"Applications",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"relations",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"influence process"),Object(l.b)("li",{parentName:"ul"},"control route export"))),Object(l.b)("li",{parentName:"ul"},"traffic engineering",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"inbound"),Object(l.b)("li",{parentName:"ul"},"outbound"),Object(l.b)("li",{parentName:"ul"},"remote control ")))))),Object(l.b)("h3",{id:"peer-2-peer"},"Peer 2 Peer"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Client/server = asymmetric"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Extension: iteratively/recursively delegate other servers to do task ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"e.g. like DNS, a tree structure"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Pure P2P"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"No central entity"),Object(l.b)("li",{parentName:"ul"},"All entities directly communicate"),Object(l.b)("li",{parentName:"ul"},"No structure; flat architecture"),Object(l.b)("li",{parentName:"ul"},"Unreliable; how to stay connected or lookup?"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Napster: Central index server"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"People register with this server"),Object(l.b)("li",{parentName:"ul"},"Central server knows all peers and files in network"),Object(l.b)("li",{parentName:"ul"},"Search peers by keyword",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Delegation; delegate downloading to P2P"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Pros"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Single server: consistent view of network"),Object(l.b)("li",{parentName:"ul"},"Fast and efficient searching"),Object(l.b)("li",{parentName:"ul"},"Guarantee correct search results"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Cons"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Single point of failure"),Object(l.b)("li",{parentName:"ul"},"Large computation to handle queires"),Object(l.b)("li",{parentName:"ul"},"Downloading from a single peer only"),Object(l.b)("li",{parentName:"ul"},"Unreliable content"),Object(l.b)("li",{parentName:"ul"},"Vulnerable to attacks"),Object(l.b)("li",{parentName:"ul"},"Copyright issues"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Gnutella: Peers are switches, flood queries"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Only peers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"People register by connecting to another active peer",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Switch topology",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Queries are flooded in the network"),Object(l.b)("li",{parentName:"ul"},"Once joined, they learn about others and learn topology"))),Object(l.b)("li",{parentName:"ul"},"Download directly from peer"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Pros"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Fully distributed"),Object(l.b)("li",{parentName:"ul"},"Open protocol"),Object(l.b)("li",{parentName:"ul"},"Robust against node failures"),Object(l.b)("li",{parentName:"ul"},"Robust to DOS"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Cons"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Inefficient queries flooding"),Object(l.b)("li",{parentName:"ul"},"Poor network management: Nodes need to keep probing "))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"KaZaA: Peers only, but some peers delegated as local server"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"2 types of nodes",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Ordinary Node (ON)"),": peer"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Supernode (SN)"),": peer with more resources & responsibilities",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Promoted from ON if it has enough resources (bandwidth & uptime)"),Object(l.b)("li",{parentName:"ul"},"Promotion is consensual with user"),Object(l.b)("li",{parentName:"ul"},"Avg lifetime of 2.5 hours"),Object(l.b)("li",{parentName:"ul"},"Don't cache info from disconnected ON"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"SN - ON : One - Many relationship"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"ON only connected to one SN (and nothing else) which acts as their gateway"))),Object(l.b)("li",{parentName:"ul"},"SN acts as local server for all connected ON"),Object(l.b)("li",{parentName:"ul"},"SN do not form a complete mesh"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Skype: Similar to KaZaA with priorietary stuff"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Similar infrastructure to KaZaA"),Object(l.b)("li",{parentName:"ul"},"P2P with proprietary application-layer encryption"),Object(l.b)("li",{parentName:"ul"},"ON and SN infrastrcuture; distributed SNs help map usernames to IP addresses"),Object(l.b)("li",{parentName:"ul"},"Problem of NAT",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"NAT prevents peers outside of network to directly connect"),Object(l.b)("li",{parentName:"ul"},"SNs are used to keep track of relay nodes"),Object(l.b)("li",{parentName:"ul"},"Relay nodes used to handle NATs"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"BitTorrent: Seed split data into chunks, tracker help leechers download from each other")," S23",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"A network (swarm) to distribute a file",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1 main server (seed) has the original copy broken into 256KB chunks"),Object(l.b)("li",{parentName:"ul"},"Seed starts tracker server",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"tracker keeps track of seeds and peers in the network (swarm)"))),Object(l.b)("li",{parentName:"ul"},"Seed creates torrent-file (metadata on chunks with checksums) and hosts it on a webserver somewhere"),Object(l.b)("li",{parentName:"ul"},"Client obtains torrent-file"),Object(l.b)("li",{parentName:"ul"},"Client contacts tracker and connects to peers"),Object(l.b)("li",{parentName:"ul"},"Client downloads/exchange data with peers",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Download rarest chunk first from neighbors")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Uploading chunks to neighbors"),": Tit-for-tat",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Send to top 4 neighbors currently sending her chunks at the highest rate, re-eval/10s"),Object(l.b)("li",{parentName:"ul"},"Send to random peer every 30s to optimistically unchoke top 4"))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Pro"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},'Can send ".torrent" link which always refer to same file'))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Con"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Hard to identify and find particular files")))))),Object(l.b)("h2",{id:"p2p-lookup-services"},"P2P lookup services"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Searching VS Addressing")),Object(l.b)("li",{parentName:"ul"},"How network is constructed",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Unstructured"),": cannot use addressing",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"But peers can join anyone and objects can be stored anywhere"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Structured"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Structured to define object locations"),Object(l.b)("li",{parentName:"ul"},"Allow deterministic routing & addressing"),Object(l.b)("li",{parentName:"ul"},"e.g. Key-value pairs, hashtables"),Object(l.b)("li",{parentName:"ul"},"Massive index: Create a ",Object(l.b)("strong",{parentName:"li"},"distributed hash table"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Every node handles multiple buckets (change as nodes join and leave)"),Object(l.b)("li",{parentName:"ul"},"Nodes communicate with each other to maintain table"))))))),Object(l.b)("li",{parentName:"ul"},"How objectives are placed"),Object(l.b)("li",{parentName:"ul"},"How efficient objects can be found"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Addressing"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Uniquely ID objects and maintain indexing structure"))),Object(l.b)("li",{parentName:"ul"},"Searching",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Need to make objects searchable"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Distributed Hashtable"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Chord")," S38",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"You have nodes and you have objects, SHA-1 Hash both of them",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Node ID: Hash Node's IP addr")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Obj ID:  Hash Object's name")))),Object(l.b)("li",{parentName:"ul"},"Store Node IDs in circular linked list S39",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Each node in array keeps track of predecessor and successor in circular array (clockwise)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"To store an object"),": Hash the object to get its object ID, then step clock-wise from ID until you find a node (i.e. ",Object(l.b)("strong",{parentName:"li"},"immediate successor"),"). That node stores the object"),Object(l.b)("li",{parentName:"ul"},"Circular linked list: O(n) time to for a node to access an object in another node",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Finger table"),": every node has shortcut links to non-neighbor nodes S43",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"At most m shortcuts"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Interval"),": ith finger at least ",Object(l.b)("span",Object(n.a)({parentName:"li"},{className:"math math-inline"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"katex"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"katex-mathml"}),Object(l.b)("math",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/1998/Math/MathML"}),Object(l.b)("semantics",{parentName:"math"},Object(l.b)("mrow",{parentName:"semantics"},Object(l.b)("msup",{parentName:"mrow"},Object(l.b)("mn",{parentName:"msup"},"2"),Object(l.b)("mrow",{parentName:"msup"},Object(l.b)("mi",{parentName:"mrow"},"i"),Object(l.b)("mo",{parentName:"mrow"},"\u2212"),Object(l.b)("mn",{parentName:"mrow"},"1")))),Object(l.b)("annotation",Object(n.a)({parentName:"semantics"},{encoding:"application/x-tex"}),"2^{i-1}")))),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"katex-html","aria-hidden":"true"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"base"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"strut",style:{height:"0.824664em",verticalAlign:"0em"}})),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord"}),"2"),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"msupsub"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-t"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"vlist-r"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"vlist",style:{height:"0.824664em"}}),Object(l.b)("span",Object(n.a)({parentName:"span"},{style:{top:"-3.063em",marginRight:"0.05em"}}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"pstrut",style:{height:"2.7em"}})),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"sizing reset-size6 size3 mtight"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord mathnormal mtight"}),"i"),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mbin mtight"}),"\u2212"),Object(l.b)("span",Object(n.a)({parentName:"span"},{className:"mord mtight"}),"1")))))))))))))," apart ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1st:1, 2nd:2, 3rd:4, 4th:8..."),Object(l.b)("li",{parentName:"ul"},"Defined as [start, end)"),Object(l.b)("li",{parentName:"ul"},"Exponential until it loops back O(log(n))"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Start"),": starting node of the interval (assuming all node IDs are occupied)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Node"),": The actual node used. If there is no node with that node ID, finger points to its immediate successor; however, the interval definition is not affected; this variable tracks that",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"i.e. if [4,6) but shifted to 5, it's still defined as [4,6) and next interval is still 4 spaces"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"When a node leaves"),": S50",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"All nodes periodically ping successors and keep track of 2nd successor"),Object(l.b)("li",{parentName:"ul"},"Predecessor will detect leave event and change its immediate sucessor"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"Efficiency"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Search: O(log(n))"),Object(l.b)("li",{parentName:"ul"},"Responsibility N nodes and K objects: O(K/N) objects per node"),Object(l.b)("li",{parentName:"ul"},"Node joining / leaving: O(logN x logN) messages to:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"re-establish routing and finger tables"),Object(l.b)("li",{parentName:"ul"},"initialize finger tables for new node"))))))))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"CAN")," S54",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Think of Chord as a 1 dimensional donut (torus)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"1 dimensional donut: predecessor and successor"))),Object(l.b)("li",{parentName:"ul"},"CAN: d-dimensional donut (torus)"),Object(l.b)("li",{parentName:"ul"},"Doesn't use finger tables, can just use neighbors (since it's d-dimensional)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"the stuff in the slides is 2D; neighbors can go up down left right.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"When a new node joins:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Cut area of responsibility by cutting vertically before cutting horizontally"))),Object(l.b)("li",{parentName:"ul"},"Object IDs are coordinates"))),Object(l.b)("li",{parentName:"ul"},"Slide 64: state refers to information maintained per node"),Object(l.b)("li",{parentName:"ul"},"Avg path length: since we know predecessor and successor, we can cut the circular path in half and take the shorter path")))))))),Object(l.b)("h2",{id:"cdn"},"CDN"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Traffic has to go through internet (middle-mile) which can be congested",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Distance between user and server negatively affects latency, throughput"),Object(l.b)("li",{parentName:"ul"},"Solutions: connect to a machine closer to client",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Big data center CDNs"),Object(l.b)("li",{parentName:"ul"},"Highly distributed CDNs"),Object(l.b)("li",{parentName:"ul"},"P2P")))))),Object(l.b)("details",null,Object(l.b)("summary",null,"Template"),Object(l.b)("p",null)))}s.isMDXComponent=!0}}]);
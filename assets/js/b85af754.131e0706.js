"use strict";(self.webpackChunkmy_docs=self.webpackChunkmy_docs||[]).push([[1530],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return c}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},N=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(a),N=r,c=u["".concat(s,".").concat(N)]||u[N]||k[N]||l;return a?n.createElement(c,i(i({ref:t},m),{},{components:a})):n.createElement(c,i({ref:t},m))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=N;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}N.displayName="MDXCreateElement"},557:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return u}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],o={title:"Network"},s=void 0,p={unversionedId:"markdown/network",id:"markdown/network",title:"Network",description:"Inter-domain Routing",source:"@site/docs/markdown/network.md",sourceDirName:"markdown",slug:"/markdown/network",permalink:"/My-Docs/docs/markdown/network",draft:!1,editUrl:"https://github.com/crazoter/My-Docs/edit/main/docs/markdown/network.md",tags:[],version:"current",frontMatter:{title:"Network"},sidebar:"someSidebar",previous:{title:"Math",permalink:"/My-Docs/docs/markdown/math"},next:{title:"CS4226 Cheatsheet",permalink:"/My-Docs/docs/markdown/CS4226_summary"}},m={},u=[{value:"Inter-domain Routing",id:"inter-domain-routing",level:2},{value:"Border Gateway Protocol (BGP)",id:"border-gateway-protocol-bgp",level:2},{value:"BGP Prefix Hijacking (S69)",id:"bgp-prefix-hijacking-s69",level:3},{value:"BGP Subprefix Hijacking (S70)",id:"bgp-subprefix-hijacking-s70",level:3},{value:"BGP in practice",id:"bgp-in-practice",level:3},{value:"Peer 2 Peer",id:"peer-2-peer",level:3},{value:"P2P lookup services",id:"p2p-lookup-services",level:2},{value:"CDN",id:"cdn",level:2}],k={toc:u},N="wrapper";function c(e){var t=e.components,a=(0,r.Z)(e,i);return(0,l.kt)(N,(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"inter-domain-routing"},"Inter-domain Routing"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"2 types of routing algos")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Comparison"),(0,l.kt)("th",{parentName:"tr",align:null},"Link State algo"),(0,l.kt)("th",{parentName:"tr",align:null},"Distance Vector algo"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Router knowledge")),(0,l.kt)("td",{parentName:"tr",align:null},"All know full network topology & link cost info"),(0,l.kt)("td",{parentName:"tr",align:null},"Only know connected neighbors & link costs (to all nodes)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Algo type")),(0,l.kt)("td",{parentName:"tr",align:null},"Global / Centralized e.g. Djikstra"),(0,l.kt)("td",{parentName:"tr",align:null},"Decentralized, iteratively by exchanging info with neighbours. Only determines next hop")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"Algo impl")),(0,l.kt)("td",{parentName:"tr",align:null},"Open Shortest Path First (OSPF)"),(0,l.kt)("td",{parentName:"tr",align:null},"Routing Info Prtcl (RIP)")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Link State Routing Limitations")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"High bandwidth: ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Topology info is flooded (to other routers)"))),(0,l.kt)("li",{parentName:"ul"},"Sensitive info released by nodes"),(0,l.kt)("li",{parentName:"ul"},"High processing overhead: Everything computed locally by node"),(0,l.kt)("li",{parentName:"ul"},"Unit representing distance is not the same for all nodes")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Distance Vector")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Send distance metric per destination "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Adv"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Hide details of topology"),(0,l.kt)("li",{parentName:"ul"},"Only next hop determined per node"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Disadv"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Inconsistent units representing distance"),(0,l.kt)("li",{parentName:"ul"},"Slow convergence due to counting-to-infinity",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Counting to infinity: (14:00) A - B - C, if link BC is cut, B will still think A can reach C and increment path cost, A will still think B can reach and increment path cost etc")))))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Path Vector")," = Extension of distance vector"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Send entire path for each destination d "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Adv"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Avoid count-to-infinity problem"),(0,l.kt)("li",{parentName:"ul"},"Detect and Avoid loops"))),(0,l.kt)("li",{parentName:"ul"},"In terms of ASes, average of only 3 hops needed (flattening of the internet as they seek to shorten the path for customers)")),(0,l.kt)("h2",{id:"border-gateway-protocol-bgp"},"Border Gateway Protocol (BGP)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Inter-domain routing protocol (Slide 13)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Allows subnet to advertise to rest of Internet"),(0,l.kt)("li",{parentName:"ul"},"Allows ASes to determine \u201cgood\u201d routes to other networks"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Main goals:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1) Fulfil agreements with other ISPs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Define who provide transit for what (based on ",(0,l.kt)("strong",{parentName:"li"},"relationship"),")",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Customer-Provider Relationship"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"AS defined as ",(0,l.kt)("strong",{parentName:"li"},"Provider"),": Provide transit service to customer"),(0,l.kt)("li",{parentName:"ul"},"AS defined as ",(0,l.kt)("strong",{parentName:"li"},"Customer"),": Pay provider for internet routing",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Types:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'"',(0,l.kt)("strong",{parentName:"li"},"multi-homing"),'" if customers has multiple providers. ',(0,l.kt)("strong",{parentName:"li"},"dual-homed")," if has 2."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Nontransit AS"),": Provider never flows traffic through customer.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"May not need BGP"),": If no need to route traffic, can just use provider's static IP, no need IDR (Slide 36)"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Selective Transit"),": Allows some AS to flow traffic through, others deny. ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Unless defined, customers never route traffic through themselves"))))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"AS Peer to peer Relationship"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"AS defined as ",(0,l.kt)("strong",{parentName:"li"},"Peering")),(0,l.kt)("li",{parentName:"ul"},"2 (big) ASes agree to transit between their customers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Only between the 2 ASes; relationship is not transitive"))),(0,l.kt)("li",{parentName:"ul"},"Usually don't pay each other"),(0,l.kt)("li",{parentName:"ul"},"Usually confidential"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Traffic Exchange Ratio")," should be roughly balanced"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Pros"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Reduce costs"),(0,l.kt)("li",{parentName:"ul"},"Improve end-to-end performance"),(0,l.kt)("li",{parentName:"ul"},"May be the only way"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Cons"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"No profit"),(0,l.kt)("li",{parentName:"ul"},"Peers are competition"),(0,l.kt)("li",{parentName:"ul"},"Peering requires periodic renegotiation"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Sibling to Sibling Relationship"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"AS-AS belong to same company"),(0,l.kt)("li",{parentName:"ul"},"Share everything"))))))),(0,l.kt)("li",{parentName:"ul"},"2) Minimize costs"),(0,l.kt)("li",{parentName:"ul"},"3) Ensure good performance for customers"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Tiers"),":",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Tier 1 AS / ISP"),": Top of the customer-provider hierarchy",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"only have peers (no upstream)"),(0,l.kt)("li",{parentName:"ul"},"Don't have to pay anyone"),(0,l.kt)("li",{parentName:"ul"},"P2P with other T1s to form a full-mesh",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Around 10-12 ASes (AT&T etc)"))),(0,l.kt)("li",{parentName:"ul"},"Lower layer: ",(0,l.kt)("strong",{parentName:"li"},"National / regional scope")),(0,l.kt)("li",{parentName:"ul"},"Stub ASes: ",(0,l.kt)("strong",{parentName:"li"},"Customers")),(0,l.kt)("li",{parentName:"ul"},"List at CAIDA AS RANK"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"BGP Implementation"),": 2 BGP routers (between ASes) exchange messages",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Depends on policy of AS (Slide 57)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Import policy"),": Don't record prefixes that you don't want your AS to help route",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Rank customer routes over peer routes"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Export policy"),": Don't advert routes you don't want neighbour ASes to use",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Providers advertises with everyone it services"),(0,l.kt)("li",{parentName:"ul"},"e.g. if AS is Customer in Customer-Provider relationship:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Customer don't want route traffic through itself",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Won't announce route to its peers"))))),(0,l.kt)("li",{parentName:"ul"},"e.g. P2P:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Don't want peers to route stuff through them to another peer:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"AS exports only customer routes to a peer"),(0,l.kt)("li",{parentName:"ul"},"AS exports a peer's routes only to its customers"))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Manipulate route preferences"),": Artificially make routes look longer / shorter to make external ASes prefer certain routes"))),(0,l.kt)("li",{parentName:"ul"},"Application layer, TCP port 179"),(0,l.kt)("li",{parentName:"ul"},"Advertise paths to different destination network prefixes"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Procedure"),": Slide 14"),(0,l.kt)("li",{parentName:"ul"},"1) BGP routers (2 AS, 1 in each AS) start session on TCP port 179, by sending ",(0,l.kt)("strong",{parentName:"li"},"OPEN")," BGP msgs and ACK by ",(0,l.kt)("strong",{parentName:"li"},"KEEPALIVE"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1.1) BGP Router also learns of prefix-port mappings from BGP route adverts from iBGPs"))),(0,l.kt)("li",{parentName:"ul"},"2) Exchange all active routes in their routing tables by sending ",(0,l.kt)("strong",{parentName:"li"},"UPDATE")," BGP msgs"),(0,l.kt)("li",{parentName:"ul"},"3) Exchange incremental updates using ",(0,l.kt)("strong",{parentName:"li"},"UPDATE"),", and correct errors using ",(0,l.kt)("strong",{parentName:"li"},"NOTIFICATION"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"UPDATE message format"),": Slide 19",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Marker (16b), Length (2b), Type (1b), Withdrawn Routes Length (2b), Withdrawn Routes  (variable), Path Attribute Length (2b), ",(0,l.kt)("strong",{parentName:"li"},"Path Attributes"),"  (variable), ",(0,l.kt)("strong",{parentName:"li"},"Network Layer Reachability Information (NLRI)"),"  (variable)"),(0,l.kt)("li",{parentName:"ul"},"Can withdraw many routes in 1 message"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"NLRI"),": Reachable IP prefixes (IP subnet mask) using route defined by ",(0,l.kt)("strong",{parentName:"li"},"Path Attribute"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g. Prefix: 138.16.64/22"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"A route consists of NLRI (prefixes) + path (defined by path attr)")),(0,l.kt)("li",{parentName:"ul"},"Thus, can only advertise 1 route per message"),(0,l.kt)("li",{parentName:"ul"},"Defining Path Attributes: Slide 21",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"well-known mandatory"),": must be included if defining new route, and must be forwarded (S23)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"ORIGIN"),": Origin of prefix"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"AS-PATH"),": Sequence of ASes in route (e.g. AS 79, AS 11)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"NEXT-HOP"),": IP Addr of BGP router in next-hop AS"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"well-known discretionary")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"optional transitive")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"optional non-transitive"),": only to adjacent AS"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"No timeout on routes"),": Invalid routes are removed with ",(0,l.kt)("strong",{parentName:"li"},"UPDATE")," message"))),(0,l.kt)("li",{parentName:"ul"},"3.1) ",(0,l.kt)("strong",{parentName:"li"},"If multiple routes to same prefix"),": Tie-break BGP routes by:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1) Shortest AS-PATH"),(0,l.kt)("li",{parentName:"ul"},"2) ",(0,l.kt)("strong",{parentName:"li"},"Hot Potato Routing"),": Get it out of AS ASAP (S30)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Use OSPF to choose closest NEXT-HOP AS router"))))),(0,l.kt)("li",{parentName:"ul"},"3.2) Update RIB (Slide 56) and forwarding table (Slide 31) using inbound UPDATEs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Build a database: Routing Information Base (RIBs)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Adj-RIBs-In: unprocessed inbound UPDATEs",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Between Adj-RIB-In and Loc-RIB: Route selection. Tie break by (Slide 65):",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1) Largest LOCAL_PREF: 4-byte unit (default 100) for BGP to indicate route preference. ",(0,l.kt)("em",{parentName:"li"},"This is not forwarded.")),(0,l.kt)("li",{parentName:"ul"},"2) Smallest AS_PATH"),(0,l.kt)("li",{parentName:"ul"},"3) Smallest ORIGIN number"),(0,l.kt)("li",{parentName:"ul"},"4) Smallest MULTI_EXIT_DISC (optional non-transitive). In use if peer AS has many BGP entry-points."),(0,l.kt)("li",{parentName:"ul"},"5) Routes from eBGP are preferred over iBGP"),(0,l.kt)("li",{parentName:"ul"},"6) Smallest interior cost based on NEXT_HOP"),(0,l.kt)("li",{parentName:"ul"},"7) COMMUNITY: for influencing neighbor's neighbors, used to group destinations"))))),(0,l.kt)("li",{parentName:"ul"},"Loc-RIB: selected best routes."),(0,l.kt)("li",{parentName:"ul"},"Adj-RIBs-Out: selected routes for advertisement to peers ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"propagate inbound UPDATE as outbound UPDATE to peers"))))),(0,l.kt)("li",{parentName:"ul"},"Maintain forwarding table of prefix-port entries (e.g. 138.16.64/22, port 4)"))),(0,l.kt)("li",{parentName:"ul"},"4) Repeat 3 forever. Close connection with ",(0,l.kt)("strong",{parentName:"li"},"NOTIFICATION")," BGP msg.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Connection down:")," Invalidate all routes through disconnected peer"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"BGP/IGP model used by ISPs")," (Slide 15)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Types of BGP: eBGP and iBGP"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"exterior BGP peering (eBGP): Between ASes")," Slide 16 ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"exchange reachability info between ASes"),(0,l.kt)("li",{parentName:"ul"},"Directly connected"),(0,l.kt)("li",{parentName:"ul"},"ASes advertise their network prefix"),(0,l.kt)("li",{parentName:"ul"},"No expiration timer for routes"),(0,l.kt)("li",{parentName:"ul"},"All routes through peer become invalid if it goes down"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"interior BGP peering (iBGP): Within AS"),": Slide 17",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Propagate reachability info to other border routers within AS"),(0,l.kt)("li",{parentName:"ul"},"Don't have to be directly connected"),(0,l.kt)("li",{parentName:"ul"},"MUST be (logically) fully meshed",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Each iBGP router pass on prefixes they learn from the other AS"),(0,l.kt)("li",{parentName:"ul"},"Does not pass on prefixes learnt from other iBGP speakers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Info not repeated, reduce overhead, scalable"))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Interior Gateway Protocol (IGP)"),": The normal network routing")))),(0,l.kt)("h3",{id:"bgp-prefix-hijacking-s69"},"BGP Prefix Hijacking (S69)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"2 ASes share the same prefix"),(0,l.kt)("li",{parentName:"ul"},"Some traffic lost to fake prefix holder:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Blackhole"),": data traffic discarded"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Spoofing / Impersonation"),": Data traffic inspected and redirected")))),(0,l.kt)("h3",{id:"bgp-subprefix-hijacking-s70"},"BGP Subprefix Hijacking (S70)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Exploit of ",(0,l.kt)("strong",{parentName:"li"},"Longer prefix matching")),(0,l.kt)("li",{parentName:"ul"},"1 AS with shorter (more general) prefix hijacked by longer (more specific) prefix",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g. 12.34.0.0/16 hijacked by 12.3.158.0/24",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"All traffic routed to 12.3.158.0/24"))),(0,l.kt)("li",{parentName:"ul"},"Can visualize with BGPlay"),(0,l.kt)("li",{parentName:"ul"},"Can prevent with anomaly detection, checking prefix ownership")))),(0,l.kt)("h3",{id:"bgp-in-practice"},"BGP in practice"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Preference (attr)"),(0,l.kt)("li",{parentName:"ul"},"Filtering (inbound/outbound filter)"),(0,l.kt)("li",{parentName:"ul"},"Tagging (COMMUNITY attr)"),(0,l.kt)("li",{parentName:"ul"},"Applications",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"relations",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"influence process"),(0,l.kt)("li",{parentName:"ul"},"control route export"))),(0,l.kt)("li",{parentName:"ul"},"traffic engineering",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"inbound"),(0,l.kt)("li",{parentName:"ul"},"outbound"),(0,l.kt)("li",{parentName:"ul"},"remote control ")))))),(0,l.kt)("h3",{id:"peer-2-peer"},"Peer 2 Peer"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Client/server = asymmetric"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Extension: iteratively/recursively delegate other servers to do task ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"e.g. like DNS, a tree structure"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Pure P2P"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"No central entity"),(0,l.kt)("li",{parentName:"ul"},"All entities directly communicate"),(0,l.kt)("li",{parentName:"ul"},"No structure; flat architecture"),(0,l.kt)("li",{parentName:"ul"},"Unreliable; how to stay connected or lookup?"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Napster: Central index server"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"People register with this server"),(0,l.kt)("li",{parentName:"ul"},"Central server knows all peers and files in network"),(0,l.kt)("li",{parentName:"ul"},"Search peers by keyword",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Delegation; delegate downloading to P2P"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Pros"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Single server: consistent view of network"),(0,l.kt)("li",{parentName:"ul"},"Fast and efficient searching"),(0,l.kt)("li",{parentName:"ul"},"Guarantee correct search results"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Cons"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Single point of failure"),(0,l.kt)("li",{parentName:"ul"},"Large computation to handle queires"),(0,l.kt)("li",{parentName:"ul"},"Downloading from a single peer only"),(0,l.kt)("li",{parentName:"ul"},"Unreliable content"),(0,l.kt)("li",{parentName:"ul"},"Vulnerable to attacks"),(0,l.kt)("li",{parentName:"ul"},"Copyright issues"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Gnutella: Peers are switches, flood queries"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Only peers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"People register by connecting to another active peer",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Switch topology",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Queries are flooded in the network"),(0,l.kt)("li",{parentName:"ul"},"Once joined, they learn about others and learn topology"))),(0,l.kt)("li",{parentName:"ul"},"Download directly from peer"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Pros"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Fully distributed"),(0,l.kt)("li",{parentName:"ul"},"Open protocol"),(0,l.kt)("li",{parentName:"ul"},"Robust against node failures"),(0,l.kt)("li",{parentName:"ul"},"Robust to DOS"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Cons"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Inefficient queries flooding"),(0,l.kt)("li",{parentName:"ul"},"Poor network management: Nodes need to keep probing "))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"KaZaA: Peers only, but some peers delegated as local server"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"2 types of nodes",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Ordinary Node (ON)"),": peer"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Supernode (SN)"),": peer with more resources & responsibilities",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Promoted from ON if it has enough resources (bandwidth & uptime)"),(0,l.kt)("li",{parentName:"ul"},"Promotion is consensual with user"),(0,l.kt)("li",{parentName:"ul"},"Avg lifetime of 2.5 hours"),(0,l.kt)("li",{parentName:"ul"},"Don't cache info from disconnected ON"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"SN - ON : One - Many relationship"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"ON only connected to one SN (and nothing else) which acts as their gateway"))),(0,l.kt)("li",{parentName:"ul"},"SN acts as local server for all connected ON"),(0,l.kt)("li",{parentName:"ul"},"SN do not form a complete mesh"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Skype: Similar to KaZaA with priorietary stuff"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Similar infrastructure to KaZaA"),(0,l.kt)("li",{parentName:"ul"},"P2P with proprietary application-layer encryption"),(0,l.kt)("li",{parentName:"ul"},"ON and SN infrastrcuture; distributed SNs help map usernames to IP addresses"),(0,l.kt)("li",{parentName:"ul"},"Problem of NAT",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"NAT prevents peers outside of network to directly connect"),(0,l.kt)("li",{parentName:"ul"},"SNs are used to keep track of relay nodes"),(0,l.kt)("li",{parentName:"ul"},"Relay nodes used to handle NATs"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"BitTorrent: Seed split data into chunks, tracker help leechers download from each other")," S23",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"A network (swarm) to distribute a file",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1 main server (seed) has the original copy broken into 256KB chunks"),(0,l.kt)("li",{parentName:"ul"},"Seed starts tracker server",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"tracker keeps track of seeds and peers in the network (swarm)"))),(0,l.kt)("li",{parentName:"ul"},"Seed creates torrent-file (metadata on chunks with checksums) and hosts it on a webserver somewhere"),(0,l.kt)("li",{parentName:"ul"},"Client obtains torrent-file"),(0,l.kt)("li",{parentName:"ul"},"Client contacts tracker and connects to peers"),(0,l.kt)("li",{parentName:"ul"},"Client downloads/exchange data with peers",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Download rarest chunk first from neighbors")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Uploading chunks to neighbors"),": Tit-for-tat",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Send to top 4 neighbors currently sending her chunks at the highest rate, re-eval/10s"),(0,l.kt)("li",{parentName:"ul"},"Send to random peer every 30s to optimistically unchoke top 4"))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Pro"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},'Can send ".torrent" link which always refer to same file'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Con"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Hard to identify and find particular files")))))),(0,l.kt)("h2",{id:"p2p-lookup-services"},"P2P lookup services"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Searching VS Addressing")),(0,l.kt)("li",{parentName:"ul"},"How network is constructed",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Unstructured"),": cannot use addressing",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"But peers can join anyone and objects can be stored anywhere"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Structured"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Structured to define object locations"),(0,l.kt)("li",{parentName:"ul"},"Allow deterministic routing & addressing"),(0,l.kt)("li",{parentName:"ul"},"e.g. Key-value pairs, hashtables"),(0,l.kt)("li",{parentName:"ul"},"Massive index: Create a ",(0,l.kt)("strong",{parentName:"li"},"distributed hash table"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Every node handles multiple buckets (change as nodes join and leave)"),(0,l.kt)("li",{parentName:"ul"},"Nodes communicate with each other to maintain table"))))))),(0,l.kt)("li",{parentName:"ul"},"How objectives are placed"),(0,l.kt)("li",{parentName:"ul"},"How efficient objects can be found"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Addressing"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Uniquely ID objects and maintain indexing structure"))),(0,l.kt)("li",{parentName:"ul"},"Searching",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Need to make objects searchable"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Distributed Hashtable"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Chord")," S38",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"You have nodes and you have objects, SHA-1 Hash both of them",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Node ID: Hash Node's IP addr")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Obj ID:  Hash Object's name")))),(0,l.kt)("li",{parentName:"ul"},"Store Node IDs in circular linked list S39",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Each node in array keeps track of predecessor and successor in circular array (clockwise)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"To store an object"),": Hash the object to get its object ID, then step clock-wise from ID until you find a node (i.e. ",(0,l.kt)("strong",{parentName:"li"},"immediate successor"),"). That node stores the object"),(0,l.kt)("li",{parentName:"ul"},"Circular linked list: O(n) time to for a node to access an object in another node",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Finger table"),": every node has shortcut links to non-neighbor nodes S43",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"At most m shortcuts"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Interval"),": ith finger at least ",(0,l.kt)("span",{parentName:"li",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mn",{parentName:"msup"},"2"),(0,l.kt)("mrow",{parentName:"msup"},(0,l.kt)("mi",{parentName:"mrow"},"i"),(0,l.kt)("mo",{parentName:"mrow"},"\u2212"),(0,l.kt)("mn",{parentName:"mrow"},"1")))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^{i-1}")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.824664em",verticalAlign:"0em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord"},"2"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.824664em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mathnormal mtight"},"i"),(0,l.kt)("span",{parentName:"span",className:"mbin mtight"},"\u2212"),(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"1")))))))))))))," apart ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1st:1, 2nd:2, 3rd:4, 4th:8..."),(0,l.kt)("li",{parentName:"ul"},"Defined as [start, end)"),(0,l.kt)("li",{parentName:"ul"},"Exponential until it loops back O(log(n))"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Start"),": starting node of the interval (assuming all node IDs are occupied)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Node"),": The actual node used. If there is no node with that node ID, finger points to its immediate successor; however, the interval definition is not affected; this variable tracks that",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"i.e. if [4,6) but shifted to 5, it's still defined as [4,6) and next interval is still 4 spaces"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"When a node leaves"),": S50",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"All nodes periodically ping successors and keep track of 2nd successor"),(0,l.kt)("li",{parentName:"ul"},"Predecessor will detect leave event and change its immediate sucessor"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Efficiency"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Search: O(log(n))"),(0,l.kt)("li",{parentName:"ul"},"Responsibility N nodes and K objects: O(K/N) objects per node"),(0,l.kt)("li",{parentName:"ul"},"Node joining / leaving: O(logN x logN) messages to:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"re-establish routing and finger tables"),(0,l.kt)("li",{parentName:"ul"},"initialize finger tables for new node"))))))))))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"CAN")," S54",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Think of Chord as a 1 dimensional donut (torus)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"1 dimensional donut: predecessor and successor"))),(0,l.kt)("li",{parentName:"ul"},"CAN: d-dimensional donut (torus)"),(0,l.kt)("li",{parentName:"ul"},"Doesn't use finger tables, can just use neighbors (since it's d-dimensional)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"the stuff in the slides is 2D; neighbors can go up down left right.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"When a new node joins:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Cut area of responsibility by cutting vertically before cutting horizontally"))),(0,l.kt)("li",{parentName:"ul"},"Object IDs are coordinates"))),(0,l.kt)("li",{parentName:"ul"},"Slide 64: state refers to information maintained per node"),(0,l.kt)("li",{parentName:"ul"},"Avg path length: since we know predecessor and successor, we can cut the circular path in half and take the shorter path")))))))),(0,l.kt)("h2",{id:"cdn"},"CDN"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Traffic has to go through internet (middle-mile) which can be congested",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Distance between user and server negatively affects latency, throughput"),(0,l.kt)("li",{parentName:"ul"},"Solutions: connect to a machine closer to client",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Big data center CDNs"),(0,l.kt)("li",{parentName:"ul"},"Highly distributed CDNs"),(0,l.kt)("li",{parentName:"ul"},"P2P")))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Template"),(0,l.kt)("p",null)))}c.isMDXComponent=!0}}]);
---
title: CS2102 Databases (Closed book, 1pg cheatsheet)
---

### Database Management Systems (DBMS)
* Data Independence
* Efficient Data access
* Data integrity & security
* Transaction Management
* Query language
* Database design
* Database programming
* **Data model**: used by DBMS, defined by user for querying the data
* **Schema**: Description of the data model
* **Schema instance**: Content of the DB at a specific time
* **Relational Model (RDBMS)**: Microsoft SQL, SAP, MySQL, SQLite
  * Data modeled using **relations** (i.e. tables)
  * Each relation defined by **relation schema**, and a relation is a set of tuples
    * Relation schema: (attributes, data constraints, domain constraints)
      * e.g. (id: int, name: text, birthDate: date)
      * Attribute: Column name
        * Must be a value in domain or null
      * Domain: datatype
      * Data constraints: e.g. non null, unique etc
        * (Data) Integrity Constraint: Specified with schema, ensure relation instance is *legal*
          * Domain constraints (datatype)
          * Key constraints
            * Non-null
            * **Superkey**: combination of attributes(columns) that uniquely identifies each tuple
            * **Key**: smallest combination of attributes that uniquely identifies each tuple
            * **Candidate Key**: possible keys
            * **Primary key** (PK): key chosen to uniquely ID each tuple
            * **Foreign key** (FK): attribute (or set of attributes) that refer to the PK of another relation
              * Must either refer to a valid PK or be set to NULL
              * FK constraints are known as **referential integrity constraints**
          * Foreign key constraints (FK must exist if set)
          * Other data constraints
    * Each row in a relation is a tuple/record has one component per attribute
    * A **relational database schema**: collection of relation schemas + data constraints
    * Relation (relation instance): A table populated with data
    * Relational database (database instance): collection of tables
* Object-relational model: Postgres

* Relational Algebra: Internals of SQL
  * Closure property: always outputs 1 table 
  * Operators:
    * Unary (1 input table)
      * Selection $\sigma_{condition}$: Select rows that satisfy condition
        * condition is ur usual bool condition {(), =, <, $\leq$, <\> (neq), op, not, and, or}. "null" can be used.
        * anything + null = null. As a result, final result can be True, False, Unknown
      * Projection $\pi_{columns}(Table)$: Select unique values from columns
      * Renaming $\rho_{col:new_name,...}(Table)$: Rename columns (e.g. need multiple instances of same data)
    * Binary (2 *union-compatible* input tables)
      * Union Compatible: Use schema of first table. Same # of columns, and columns have same domain order. Names don't have to be the same
      * Union (U) (in R or S, rm dupes), Intersect ($\cap$) (in R & S), Set-difference (R-S) (in R but not S)
      * Cross Product (x): concat the columns of both tables, generate all pairwise permutations of tuples from each table
  * Methodologies:
    * 1. Draw a tree
    * 2. Sequence of steps (Each line stores the operation result as a new relation)
  * Joins (combinations of operators):
    * Inner join ($R\bowtie_{cond}S = \sigma_{cond}(R x S)$): Cross product, then select by condition
    * Natural join ($R\bowtie S$): Cross product, then drop duplicate columns from S
      * Inner join on all columns with same name, rm duplicate cols
    * Outer joins: inner join, but also include dangling tuples (rows that failed condition). For these tuples, since unjoined, will have unknown data; fill those cols with null
      * R $\rightarrow_{cond} S$: include dangling tuples from R
      * R $\leftarrow_{cond} S$: include dangling tuples from S
      * R $\leftarrow\rightarrow_{cond} S$: include dangling tuples from R then S
      * If condition not included, it's natural outer join
* SQL: Structured Query Language (declarative)
  * domain-specific language (DSL)
  * Data Definition Language (schemas)
    * Constraints
      * Not-null, Unique, PK, FK, General
      * Column, Table, Assertions (not supposed for most DBMS, constraints enforced by triggers)
    * `CREATE TABLE table (col_name_by_newline, [constraints])`;
      * column entry: `colName datatype [PRIMARY KEY] [UNIQUE] [NOT NULL] [DEFAULT value] [REFERENCES y (colInY)] [CHECK (condition)],`
        * Primary key: automatically unique & not null
      * constraint entries: 
        * General format: `[CONSTRAINT name] unique/composite/fk [DEFERRABLE INITIALLY DEFERRED|IMMEDIATE ]`
        * Unique: `UNIQUE (col1, col2)`
        * Composite: `PRIMARY KEY (col1, col2, ...)`
        * Foreign Key: `FOREIGN KEY (colInX [, ...]) references y (colInY [, ...]) [MATCH FULL] [ON DELETE refAction] [ON UPDATE refAction]`
          * If FK is composite, partial nulls are allowed unless `MATCH FULL` is specified. 
        * Condition: `CHECK (column constraints e.g. 'day in (1,2,3))'`
        * Named constraint: add `CONSTRAINT name` in front of the constraint
        * refAction (for when new FK is invalid / is in use): `RESTRICT` (reject operation, not deferred) | CASCADE (changes from parent propagates) | SET NULL (set any FK references to null) | NO ACTION (same as restrict, deferrable) | SET DEFAULT (set any FK references to default value specified in schema)`
        * Deferred checking: only for `UNIQUE | PK | FK`
          * `INITIALLY DEFERRED`: Checks will only be conducted at end of transaction.
          * `INITIALLY IMMEDIATE`: Checks enforced per query, but you can call `SET CONSTRAINTS constraintName DEFERRED` to defer it
    * `DROP TABLE [IF EXISTS] x [CASCADE]`;
      * `CASCADE`: Drop objects that have foreign keys linked to table
    * Schema Modification
      * `ALTER TABLE table ALTER COLUMN columnName [DROP addOn (e.g. DEFAULT)]`
      * `ALTER TABLE table DROP COLUMN columnName`
      * `ALTER TABLE table ADD COLUMN (column entry)`
      * `ALTER TABLE table ADD CONSTRAINT (constraint entry)`
  * Data Manipulation Lanuage (queries)
    * `INSERT INTO table [(col1, col2...)] VALUES tuple1, tuple2...` 
    * `DELETE FROM table [WHERE condition]`
    * `UPDATE table SET col = col + i [WHERE condition]`
  * Transactions
    * Wrap a series of queries using `BEGIN;` and `COMMIT;`
    * Enforces **ACID**:
      * Atomicity: results of queries all shown or not
      * Consistency: Change in data will always abide all rules (constraints, cascades, triggers etc)
      * Isolation: Can be considered to be "serializable"; not affected by other reads & writes
      * Durability: Committed transaction will work even if system fails
    * Deferrable constraints: defer checks to the end of transaction
    * 
  * Datatypes
    * boolean, smallint, integer, float8, numeric, numeric(max_n, decimal), char(fixed_n), varchar(n), text, date, timestamp
  * NULL
    * Same as relational: comparison & arithmetic with null = unknown result
  * Operations
    * x IS NULL, x IS DISTINCT FROM y
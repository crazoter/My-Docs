<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.66">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Python Reference | Matt&#x27;s Docs</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Python Reference | Matt&#x27;s Docs"><meta data-react-helmet="true" name="description" content="These are my notes from datacamp."><meta data-react-helmet="true" property="og:description" content="These are my notes from datacamp."><meta data-react-helmet="true" property="og:url" content="https://crazoter.github.io/My-Docs/docs/markdown/python"><link data-react-helmet="true" rel="shortcut icon" href="/My-Docs/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://crazoter.github.io/My-Docs/docs/markdown/python"><link rel="stylesheet" href="/My-Docs/styles.cf4aaf38.css">
<link rel="preload" href="/My-Docs/styles.b91a0882.js" as="script">
<link rel="preload" href="/My-Docs/runtime~main.e11f927f.js" as="script">
<link rel="preload" href="/My-Docs/main.8dcec96c.js" as="script">
<link rel="preload" href="/My-Docs/1.59cfe348.js" as="script">
<link rel="preload" href="/My-Docs/2.4d5607e9.js" as="script">
<link rel="preload" href="/My-Docs/51.70720b25.js" as="script">
<link rel="preload" href="/My-Docs/52.59cf3399.js" as="script">
<link rel="preload" href="/My-Docs/935f2afb.33106336.js" as="script">
<link rel="preload" href="/My-Docs/17896441.75674ef7.js" as="script">
<link rel="preload" href="/My-Docs/991d0552.dcb30ccd.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/My-Docs/"><img class="navbar__logo" src="/My-Docs/img/ibuki.png" alt="My Site Logo"><strong class="navbar__title">Matt&#x27;s Docs</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/My-Docs/docs/">Docs</a><a class="navbar__item navbar__link" href="/My-Docs/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/crazoter/My-Docs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/My-Docs/"><img class="navbar__logo" src="/My-Docs/img/ibuki.png" alt="My Site Logo"><strong class="navbar__title">Matt&#x27;s Docs</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/My-Docs/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/My-Docs/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/crazoter/My-Docs" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Docusaurus</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/docusaurus/usage">Usage</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/docusaurus/doc1">Style Guide</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/docusaurus/mdx">Powered by MDX</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">AI</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS4246_summary">CS4246 Cheatsheet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/ai_planning">AI Planning (CS4246, Reinforcement Learning)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/computer_vision">Computer Vision</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/machine_learning">Machine Learning</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS3244">CS3244 Machine Learning</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Cybersec</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS4238">CS4238 Computer Security Practice &quot;Cheatsheet&quot;</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Quantum</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS4268">CS4268 Quantum Computing</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Languages</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/My-Docs/docs/markdown/python">Python Reference</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Math</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/math">Math</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Networks</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/network">Network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS4226_summary">CS4226 Cheatsheet</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Software Development</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/algorithms">Tips &amp; Tricks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/formal_verification">Formal Verification</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/problem_summaries">Problems</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Databases</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS2102">CS2102 Databases (Closed book, 1pg cheatsheet)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Misc</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/">Tech lookup</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/code_snippets">Code Snippets</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Hobbies</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/manga_reviews">Manga Reviews</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/book_summaries">Book Summaries</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/book_contemplations">Book Contemplations</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Python Reference</h1></header><div class="markdown"><p>These are my notes from datacamp.</p><p>Legend:</p><ul><li>#: Number, used for differentiating variables</li><li>L#: List.</li><li>D#: Dictionary. </li><li>itr#: Iterable.</li><li>DF#: Dataframe</li><li>mltIdx#: MultiIndex</li><li>idx: Index</li><li>int#: Integer variable</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="project-setup"></a><a href="https://docs.python-guide.org/writing/structure/" target="_blank" rel="noopener noreferrer">Project setup</a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#project-setup" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="pure-python"></a>Pure Python<a aria-hidden="true" tabindex="-1" class="hash-link" href="#pure-python" title="Direct link to heading">#</a></h2><ul><li>Exponentiation: val ** power</li><li>Type conversion: <em>type</em>(val), where <em>type</em> in {int, float, str, bool}</li><li>Iterables<ul><li><strong>Loop with Index</strong>: for idx, val in enumerate(itr)</li><li><strong>Generators (lazy loading iteration)</strong><ul><li>Creation: <ul><li><code>gen = iter(L / D / *range(i)*)</code></li><li><code>gen = (x for x in list)</code></li><li><code>gen = def fx(param): ... for x in param: yield x ...</code></li></ul></li><li>Use:    val = next(itr)</li></ul></li></ul></li><li>Lists<ul><li><strong>Init with List Comprehension</strong><ul><li>Format: <code>[ (value) for (var_name) in (iterable) if (predicate) ]</code><ul><li>e.g. [L[0] for elem in list]</li></ul></li></ul></li><li>List of tuples:<ul><li><strong>Convert L to L of indexed tuples:</strong><ul><li><code>enumerate(itr, start=int1) = [(int1,itr[0]), (int1+1,itr[0])...]</code></li></ul></li><li>Merge two lists into a list of tuples:<ul><li><code>zip(*L1*,*L2*)</code><ul><li>returns zipObject: [ (L1[0],L2[0]),  (L1[1],L2[1])... ]</li><li>Access zipObject contents: (*zipObj)</li></ul></li><li>Unzip: <code>zip(*zipObj)</code></li></ul></li></ul></li><li>Count occurrences: <code>list.count(obj)</code></li></ul></li><li>Dictionaries<ul><li><strong>Init with Dictionary Comprehension</strong><ul><li>Format: <code>{ (key : value) for (var_name) in (iterable) if (predicate) }</code><ul><li>e.g. {x : len(x) for x in list}</li></ul></li></ul></li><li><strong>Init from list of tuples</strong><ul><li><code>dict(zip(L1,L2))</code></li></ul></li></ul></li><li>Functions:<ul><li>Default params: x=default</li><li>Flexible list param: <code>f(*args)</code><ul><li>Usage: f(v1,v2,v3...)</li></ul></li><li>Flexible dict param: <code>f(**kwargs)</code><ul><li>Usage: f(k1=v1,k2=v2,k3=v3...)</li></ul></li><li>Multiple output: <ul><li>def fx(): return (x, y)</li><li>Multiple assignment:<ul><li>x,y = fx()</li></ul></li></ul></li><li>Global variables: <code>global varname</code></li><li>Nested functions:<ul><li>Variables &amp; params of external f() is accessible</li><li>The function itself can be returned</li><li>Modify variables from nested f(): <code>nonlocal varname</code></li></ul></li></ul></li><li>Functional Programming<ul><li><code>map((lambda a: (transformation)), L)</code></li><li><code>filter((lambda a: (predicate)), L)</code></li><li><code>reduce((lambda a,b: ...), L) = result</code><ul><li>Import: <code>from functools import reduce</code></li></ul></li><li>The lambda can be replaced with a concrete function</li></ul></li><li>Lambdas<ul><li><code>(lambda (params): (body))</code></li><li>e.g. (lambda a: a+1) â‰¡ def f(a): return a+1</li><li>No &quot;return&quot;</li><li>No multi-line</li></ul></li><li>Exception Handling<ul><li>try: ... </li><li>except: ... </li><li>raise <em>Error</em>(<em>msg</em>)<ul><li>Error = {ValueError, TypeError, YourOwnErrClass}</li></ul></li></ul></li><li>I/O<ul><li>Open file:<ul><li><code>with open(&#x27;filepath&#x27;) as file_var</code><ul><li><code>file_var.readline()</code>: returns None if empty</li></ul></li></ul></li><li>Get script directory:<ul><li><code>dir_path = os.path.dirname(os.path.realpath(__file__))</code></li></ul></li><li>Get path to file relative to script directory:<ul><li><code>local_file = os.path.join(dir_path, &#x27;path&#x27;, &#x27;to&#x27;, &#x27;local_file&#x27;)</code></li></ul></li></ul></li><li>Datetime<ul><li>Req: <code>import datetime as dt</code></li><li><code>dt.date.today()</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="libraries--modules"></a>Libraries / Modules<a aria-hidden="true" tabindex="-1" class="hash-link" href="#libraries--modules" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="regex"></a>Regex<a aria-hidden="true" tabindex="-1" class="hash-link" href="#regex" title="Direct link to heading">#</a></h3><ul><li><strong>Create Pattern</strong>: <code>pattern = re.compile(r&quot;regex_pattern&quot;)</code></li><li><strong>Match</strong>: <code>matches = re.match(pattern, str)</code><ul><li>Returns None if no matches found</li><li><strong>Get found values</strong>: <code>matches.group(n), n = 0 if no groups defined</code> </li></ul></li><li></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recordlinkage-join-datasets-wo-common-uid"></a>Recordlinkage (Join datasets w/o common UID)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recordlinkage-join-datasets-wo-common-uid" title="Direct link to heading">#</a></h3><ul><li><code>import recordlinkage</code></li><li>Purpose: <strong>Join different datasets when they don&#x27;t share a unique identifier.</strong> See <a href="https://recordlinkage.readthedocs.io/en/latest/ref-index.html" target="_blank" rel="noopener noreferrer">Documentation</a><ol><li><strong>Init an indexer</strong></li></ol><ul><li><code>idxr = recordlinkage.Index()</code></li></ul><ol start="2"><li>Blocking: only <strong>choose pairs of entries that have the same value under specified column</strong> (e.g. &quot;cuisine_type&quot;)</li></ol><ul><li><code>idxr.block(&quot;col_name&quot;)</code></li></ul><ol start="3"><li><strong>Generate said pairs of indexes</strong> which agree on the equal columns</li></ol><ul><li><code>mltIdx_pairs = idxr.index(df1, df2)</code><ul><li>Example pair: MultiIndex([(0,0),(0,1),(0,7),(1,0),(1,4)...])</li></ul></li></ul><ol start="4"><li><strong>Specify the columns to compare</strong> with a Compare object</li></ol><ul><li><code>comp = recordlinkage.Compare()</code><ul><li>Then, specify the columns to compare by:<ul><li><code>comp.exact(&#x27;col_nm_in_df1&#x27;, &#x27;col_nm_in_df2&#x27;, label=&#x27;new_lbl_in_new_df&#x27;)</code><ul><li>Entries must <strong>exact match</strong> in the columns</li><li>e.g. comp.exact(&#x27;city&#x27;, &#x27;city&#x27;, label=&#x27;city&#x27;)</li></ul></li><li><code>comp.string(&#x27;col_nm_in_df1&#x27;, &#x27;col_nm_in_df2&#x27;, label=&#x27;new_lbl_in_new_df&#x27;, threshold = dbl_frm_0-1)</code> (threshold usually 0.8)</li><li>Entries must be <strong>similar</strong> (in terms of string) in the columns</li></ul></li></ul></li></ul><ol start="5"><li>Apply the Compare object to <strong>get a dataframe highlighting potential matches</strong></li></ol><ul><li><code>df_pttl_mtchs = comp.compute(mltIdx_pairs, df1, df2)</code><ul><li>Structure of df_pttl_mtchs:<ul><li>Index / Col 0: mltIdx_pairs</li><li>Columns: columns used for comparison<ul><li>exact: 1 if equal else 0</li><li>string: 1 if threshold met, else 0</li></ul></li></ul></li></ul></li></ul><ol start="6"><li><strong>Filter matches</strong> from potential matches</li></ol><ul><li><code>df_mtchs = df_pttl_mtchs[df_pttl_mtchs.sum(axis=1) &gt;= 3]</code><ul><li>If the val == 1 then there&#x27;s a match on that column. This counts the number of matched columns, and filters by that.</li><li>In this case there were 3 columns so 3 was chosen</li></ul></li></ul><ol start="7"><li><strong>Select matched indexes</strong> for one of the DFs (in this case df2)<ul><li><code>idx_df2_mtched = df_mtchs.index.get_level_values(1)</code><ul><li>df_pttl_mtchs &amp; df_mtchs use a MultiIndex. </li><li>df_mtchs.index.get_level_values(0) = df1&#x27;s indexes, (1) = df2&#x27;s indexes</li></ul></li></ul></li><li><strong>From df2, remove entries that match df1&#x27;s entries</strong></li></ol><ul><li><code>df2_notInDf1 = df2[~df2.index.isin(idx_df2_mtched)]</code></li></ul><ol start="9"><li><strong>Join df1 and the new df2 entries</strong></li></ol><ul><li><code>df1.append(df2_notInDf1)</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="fuzzywuzzy-string-comparison"></a>fuzzywuzzy (String Comparison)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#fuzzywuzzy-string-comparison" title="Direct link to heading">#</a></h3><ul><li><strong>Import</strong>: <code>from fuzzywuzzy import process</code></li><li><strong>Test similarity:</strong> <code>process.extract(&#x27;target_word&#x27;, arr_of_candidate_words, length_of_arr)</code><ul><li>Returns array of tuples: <code>[(&#x27;candidate_word&#x27;, similarity_score), ...]</code><ul><li>similarity_score: from 0 - 100, 100 as perfect, 80 as close enough</li></ul></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="missingno-visualize-missing-data"></a>missingno (Visualize missing data)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#missingno-visualize-missing-data" title="Direct link to heading">#</a></h3><ul><li><code>import missingno as msno</code></li><li>msno.matrix(df_with_missingvals); plt.show()</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="scipystats-zscore"></a>scipy.stats (zscore)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#scipystats-zscore" title="Direct link to heading">#</a></h3><ul><li><code>from scipy.stats import zscore</code></li><li>calculate zscore values: <code>zscore(df[&#x27;col&#x27;])</code><ul><li>z-score is the number of standard deviations by which an observation is above the mean - so if it is negative, it means the observation is below the mean.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="textatistic-evaluate-word-readability"></a>Textatistic (Evaluate word readability)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#textatistic-evaluate-word-readability" title="Direct link to heading">#</a></h3><ul><li><code>from textatistic import Textatistic</code></li><li>Compute scores: <code>scores = Textatistic(article/string).scores</code></li><li>Get Flesch score: <code>scores[&#x27;flesch_score&#x27;]</code></li><li>Get gunningfog: <code>scores[&#x27;gunningfog_score&#x27;]</code></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="spacy-tokenization-and-lemmatization"></a>spacy (tokenization and lemmatization)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#spacy-tokenization-and-lemmatization" title="Direct link to heading">#</a></h3><ul><li><code>import spacy</code></li><li>Tokenization</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import spacy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Load the en_core_web_sm model which comes with the spaCy library (see https://spacy.io/models/en)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nlp = spacy.load(&#x27;en_core_web_sm&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Create a Doc object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc = nlp(gettysburg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Generate the tokens</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tokens = [token.text for token in doc]</span></div></div></div></div></div><ul><li>Lemmatization (accuracy dependent on moduel)</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import spacy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Load the en_core_web_sm model</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nlp = spacy.load(&#x27;en_core_web_sm&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Create a Doc object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc = nlp(gettysburg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Generate lemmas (accuracy dependent on model)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">lemmas = [token.lemma_ for token in doc]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Convert lemmas into a string</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(&#x27; &#x27;.join(lemmas))</span></div></div></div></div></div><ul><li>Preprocess with lemmatization, removing non alphabeticals</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Function to preprocess text</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def preprocess(text):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Create Doc object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    doc = nlp(text, disable=[&#x27;ner&#x27;, &#x27;parser&#x27;])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Generate lemmas</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    lemmas = [token.lemma_ for token in doc]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Remove stopwords and non-alphabetic characters</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    a_lemmas = [lemma for lemma in lemmas </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if lemma.isalpha() and lemma not in stopwords]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return &#x27; &#x27;.join(a_lemmas)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Apply preprocess to ted[&#x27;transcript&#x27;]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ted[&#x27;transcript&#x27;] = ted[&#x27;transcript&#x27;].apply(preprocess)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(ted[&#x27;transcript&#x27;])</span></div></div></div></div></div><ul><li>POS (piece-of-speech) tagging </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Load the en_core_web_sm model</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nlp = spacy.load(&#x27;en_core_web_sm&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Create a Doc object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc = nlp(lotf)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Generate tokens and pos tags</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pos = [(token.text, token.pos_) for token in doc]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(pos) </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Output: [(&#x27;He&#x27;, &#x27;PRON&#x27;), (&#x27;found&#x27;, &#x27;VERB&#x27;), (&#x27;himself&#x27;, &#x27;PRON&#x27;), (&#x27;understanding&#x27;, &#x27;VERB&#x27;) ...</span></div></div></div></div></div><ul><li>Named Entities Recognition (NER)</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Load the required model</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nlp = spacy.load(&#x27;en_core_web_sm&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Create a Doc instance </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">text = &#x27;Sundar Pichai is the CEO of Google. Its headquarters is in Mountain View.&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc = nlp(text)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Print all named entities and their labels</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for ent in doc.ents:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(ent.text, ent.label_)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Output:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Sundar Pichai ORG</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Google ORG</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Mountain View GPE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Alternatively:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def find_persons(text):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Create Doc object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  doc = nlp(text)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Identify the persons</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  persons = [ent.text for ent in doc.ents if ent.label_ == &#x27;PERSON&#x27;]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Return persons</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return persons</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(find_persons(tc))</span></div></div></div></div></div><ul><li><p>Word embeddings</p><ul><li>Compare similarities</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Create the doc object</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doc = nlp(sent)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute pairwise similarity scores</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for token1 in doc:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for token2 in doc:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    print(token1.text, token2.text, token1.similarity(token2))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Similarity between 2 documents</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nlp(doc1).similarity( nlp(doc2) )</span></div></div></div></div></div></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="matplotlibpyplot-graphs--images"></a>matplotlib.pyplot (Graphs &amp; Images)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#matplotlibpyplot-graphs--images" title="Direct link to heading">#</a></h3><p><code>import matplotlib.pyplot as plt</code></p><ul><li><p>Think of <code>plt</code> as some kind of a global variable to attach stuff to</p></li><li><p>Change Styles:</p><ul><li><strong>Use style</strong>: <code>plt.style.use(style_name)</code></li><li><strong>Show available styles</strong>: <code>plt.style.available</code></li><li><strong>Improve the spacing between subplots</strong>: <code>plt.tight_layout()</code></li><li><strong>Hide gridlines</strong>: <code>plt.grid(&#x27;off&#x27;)</code></li><li><strong>Hide axes</strong>: <code>plt.axis(&#x27;off&#x27;)</code></li></ul></li><li><p>Graphs</p><ul><li><p>Create multiple graphs:</p><ul><li>Automatically using <code>plt.subplot(rows, columns, active_subplot_idx)</code><ul><li>Call the function with a new <code>active_subplot_idx</code> = row x rowlen * column to change the current graph.<ul><li><code>active_subplot_idx</code> starts from 1</li></ul></li></ul></li><li>Specify axes directly: </li><li><strong>Define bounding box (axes)</strong>: <code>plt.axes([xlower, ylower, width_%, height_%])</code>, args passed as a list<ul><li>Think of these as rectangle bounds of your current graph.<ul><li>e.g. if you want 2 graphs side-by-side: <ul><li>First set the axes for the left one <code>plt.axes([0.05, 0.05, 0.425, 0.9])</code> </li><li>Then plot the left graph <code>plt.plot(year, physical_sciences, color=&#x27;blue&#x27;)</code></li><li>The set the axes for the right one <code>plt.axes([0.525, 0.05, 0.425, 0.9])</code></li><li>and plot that graph <code>plt.plot(year, computer_science, color=&#x27;red&#x27;)</code></li></ul></li></ul></li></ul></li></ul></li><li><p>Plot graph in active subplot:</p><ul><li><strong>Plot line</strong>:</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.plot(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    OPTION 1 WITH TWO LISTS: x_positions_of_points, y_positions_of_points, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    OPTION 2 WITH 1 DATAFRAME: dataframe_of_x_and_y </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    color=&#x27;blue&#x27;, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    label=str     # Used to label the line in the legend</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li><strong>Scatter</strong>: <code>plt.scatter(x_data, y_data, label=&#x27;data&#x27;, color=&#x27;red&#x27;, marker=&#x27;o&#x27;)</code></li><li><strong>Histogram</strong>: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.hist(pixels, bins=64, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    range=(0, 256),   # x-axis range</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    normed=True,      # normalized histogram</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cumulative=True,  # cumulative density function instead of probability density function</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    color=&#x27;red&#x27;, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    alpha=0.4,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    histtype=&#x27;bar&#x27;      # https://matplotlib.org/3.2.1/gallery/statistics/histogram_histtypes.html</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Alternatively</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">dataframe.hist()</span></div></div></div></div></div><ul><li><strong>Empirical CDF</strong>:  </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def ecdf(data):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Compute ECDF for a one-dimensional array of measurements.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Return x and y data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return (np.sort(data), np.arange(1, len(data)+1) / n)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">x1, y1 = ecdf(data_list1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">x2, y2 = ecdf(data_list2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.plot(x1, y1, marker=&#x27;.&#x27;, linestyle = &#x27;none&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.plot(x2, y2, marker=&#x27;.&#x27;, linestyle = &#x27;none&#x27;) # marker=&#x27;D&#x27; for diamonds</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.legend((&#x27;data 1&#x27;, &#x27;data 2&#x27;), loc=&#x27;lower right&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.show()</span></div></div></div></div></div><ul><li><strong>Boxplot</strong>: <code>dataframe.boxplot(column = [y_axis_col_values], by=[x_axis_col_values])</code></li><li><strong>Add title</strong>: <code>plt.title(str)</code></li><li><strong>Change x and y labels</strong>: <code>plt.xlabel(str)</code> and <code>plt.ylabel(str)</code></li><li><strong>Change x and y limits (set range)</strong>: <code>plt.xlim(lower,upper)</code> and <code>plt.ylim(lower,upper)</code><ul><li>Inclusive</li><li><strong>Change both at the same time</strong>: <code>plt.axis((x_lower,x_upper,y_lower, y_upper))</code></li></ul></li><li><strong>Configuring xticks / yticks</strong>: <code>plt.xticks(rotation=degs)</code> and <code>plt.yticks(rotation=degs)</code><ul><li>ticks: the markers showing the coordinates on the x and y axis</li><li>rotation: angle at which ticks are displayed</li></ul></li></ul></li><li><p><strong>Add legend</strong>: <code>plt.legend((label1, label2, ...), loc=&#x27;lower center&#x27;)</code></p></li><li><p><strong>Overlay plots</strong>: <code>plt.twinx()</code></p><ul><li>Use plt.twinx() to overlay plots with different vertical scales on a common horizontal axis.</li></ul></li><li><p><strong>Annotate</strong></p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.annotate(text, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    xy=(x_pos, y_pos),    # xy of value you&#x27;re pointing to</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    xytext=(x_pos, y_pos), </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    arrowprops=dict(facecolor=&#x27;black&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div></li><li><p><strong>2D histogram</strong>:</p><ul><li><code>plt.hist2d(horizontal_data, vertical_data, bins=(x_cols, y_rows), range=((x_min, x_max), (y_min, y_max)))</code></li><li>Range is optional</li><li>Instead of plotting the points directly on a graph, you turn it into something of a density map; the graph is split into a grid, and boxes with a lot of points will have a color of higher intensity.</li></ul></li><li><p><strong>2D hex histogram</strong>:</p><ul><li><code>plt.hexbin(horizontal_data, vertical_data, gridsize=(x_cols, y_rows), extent=(x_min, x_max, y_min, y_max))</code></li></ul></li><li><p><strong>Display points w/ color</strong>: <code>plt.pcolor(2D_arr,...)</code></p><ul><li>Add param <code>cmap=&#x27;Blues&#x27;</code> to config colormapping to Blues</li></ul></li><li><p><strong>Display color and intensity mapping</strong>: <code>plt.colorbar()</code></p><ul><li>Note that the bottom left part of the image maps to the top left part of the numpy array</li></ul></li><li><p><strong>Display points as contours</strong>: <code>plt.contour(X, Y, Z, contour_count, cmap=&#x27;color_map&#x27;)</code></p><ul><li>Filled: <code>plt.contourf(...)</code></li><li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/04.04-density-and-contour-plots.html" target="_blank" rel="noopener noreferrer">See</a></li></ul></li></ul></li><li><p>Images</p><ul><li><strong>Load image</strong>: <code>npRGB = plt.imread(filepath)</code></li><li><strong>Display image</strong>: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.imshow(npRGB,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cmap=&#x27;gray&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    extent=(-1, 1, -1, 1) # horizontal extent from -1 to 1, vertical extent from -1 to 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    aspect=1              # aspect ratio (# of vertical pixels : # of horizontal pixels). </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                          # \lt 1 means img is squashed downwards; \gt 1 means img is stretched upwards</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li>Add cmap if only 1 channel</li><li><strong>RGB to monochannel</strong>: <code>npRGB.sum(axis=2)</code></li><li>Others:<ul><li><strong>Split RGB into channels:</strong><ul><li><code>red, green, blue = img[:,:,0], img[:,:,1], img[:,:,2]</code></li><li><strong>Flatten monochannel image (without modifying values) into 1-D array</strong>: <code>image.flatten()</code></li></ul></li><li>Normalize intensity:<ul><li><code>256*(img-img.min())/(img.max()-img.min())</code></li></ul></li></ul></li></ul></li><li><p>Export:</p><ul><li><strong>Show on GUI</strong>: <code>plt.show()</code></li><li><strong>Prepare graph on another figure</strong>: <code>plt.figure()</code></li><li><strong>Save to file</strong>: <code>plt.savefig(filepath)</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="seaborn-graphs"></a>Seaborn (Graphs)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#seaborn-graphs" title="Direct link to heading">#</a></h3><ul><li><p><code>import seaborn as sns</code></p></li><li><p>Set default style: <code>sns.set()</code></p></li><li><p><strong>Simple linear regression</strong>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.lmplot(x=&#x27;x_pos_col_in_df&#x27;, y=&#x27;y_pos_col_in_df&#x27;, data=dataframe</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    hue=&#x27;categorical_col_in_df&#x27;, # This col is categorical; will be used to group the points by colour</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    row=&#x27;groupby_row_wise&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    palette=&#x27;Set1&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li>straight line best fit</li><li>hue: e.g. you have a col &quot;gender&quot; that allows only {&#x27;M&#x27;,&#x27;F&#x27;}. <ul><li>Graph will color points that have value &#x27;M&#x27; to one color, and &#x27;F&#x27; to another color (i.e. groupby)</li></ul></li><li>row: same purpose as hue, but groupby row-wise<ul><li>i.e. Segregate points by each category and plot a separate graph for each</li></ul></li><li>plots on current plt graph. Use <code>plt.show()</code> to show </li></ul></li><li><p><strong>2nd order regression</strong>: </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.regplot(x=&#x27;x_col_in_df&#x27;, y=&#x27;y_col_in_df&#x27;, data=dataframe,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    color=&#x27;green&#x27;, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    scatter=None,         # Set scatter to None if you don&#x27;t want to plot the scatter points; else ignore this line</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    order=2,              # 1 for simple lin. regr., 2 for 2nd order etc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    label=&#x27;legend_label&#x27;  # label for legend</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li>curved line best fit</li><li></li></ul></li><li><p><strong>Residual plot</strong>: <code>sns.residplot(x=&#x27;x_col_in_df&#x27;, y=&#x27;y_col_in_df&#x27;, data=dataframe, color=color_str)</code></p><ul><li>Visualize how far datapoints diverge from the regression line (a &quot;residual&quot; is the distance from a datapoint to the line)</li></ul></li><li><p><strong>box plot</strong>: <code>sns.boxplot(x=&#x27;east_west&#x27;, y=&#x27;dem_share&#x27;, data=df_all_states)</code></p></li><li><p><strong>Strip plot</strong>: A scatter plot where the x axis represents a categorical variable.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.stripplot(x=&#x27;x_col_in_df&#x27;, y=&#x27;y_col_in_df&#x27;, data=df,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    size = n,   # Size of dots</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    jitter=True # Useful when many points overlap, easier to see distribution. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li><a href="https://seaborn.pydata.org/generated/seaborn.stripplot.html" target="_blank" rel="noopener noreferrer">Documentation</a></li></ul></li><li><p><strong>Swarm plot</strong>: Similar to strip plot, but the points visually spread out to avoid overlap</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.swarmplot(x=&#x27;x_col_in_df&#x27;, y=&#x27;y_col_in_df&#x27;, data=df,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    orient = &#x27;h&#x27;/&#x27;v&#x27;  # h: y is now the categorical var. v: same as stripplot</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    size = n,         # Size of dots</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    hue=&#x27;col&#x27;,        # Categorical column to colour points by</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div></li><li><p><strong>Violin plot</strong>: Similar to a box plot, with the addition of a rotated kernel density plot on each side</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.violinplot(x=&#x27;x_col_in_df&#x27;, y=&#x27;y_col_in_df&#x27;, data=df,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    color=&#x27;lightgray&#x27;,  # If you want all violins to be of the same color</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    inner=None          # Points are visualized in the center of each x coord. inner=None to only show the violin body.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div></li><li><p><strong>Joint plot</strong>: Main plot in the middle defined by <code>kind</code>, combined with histograms aligned to the x and y axis at the side.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.jointplot(x=&#x27;hp&#x27;, y=&#x27;mpg&#x27;,data=auto,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    kind = &#x27;scatter&#x27; | &#x27;reg&#x27; | &#x27;resid&#x27; | &#x27;kde&#x27; | &#x27;hex&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li>kind=&#x27;scatter&#x27;: scatter plot of the data points</li><li>kind=&#x27;reg&#x27;: regression plot (default order 1)</li><li>kind=&#x27;resid&#x27;: residual plot</li><li>kind=&#x27;kde&#x27;: kernel density estimate of the joint distribution</li><li>kind=&#x27;hex&#x27;: hexbin plot of the joint distribution</li></ul></li><li><p><strong>Pair(wise) plot</strong>: Take every pairwise combination of every non-categorical column in dataframe and plot main plot + histogram.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.pairplot(df, kind = &#x27;scatter&#x27; | &#x27;reg&#x27; | &#x27;resid&#x27; | &#x27;kde&#x27; | &#x27;hex&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    hue = &#x27;categorical_col&#x27; # Categorical column to colour points by</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)```</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div></div></div></li><li><p><strong>Heatmap</strong>: Good for visualizing 2D arrays (e.g. covariance matrices)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.heatmap(df, linewidths=1, linecolor=&#x27;black&#x27;)</span></div></div></div></div></div></li><li><p><strong>Countplot</strong>: Good for binary features</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sns.countplot(x=&#x27;education&#x27;, hue=&#x27;party&#x27;, data=df, palette=&#x27;RdBu&#x27;)</span></div></div></div></div></div></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="scikit-learn"></a>scikit-learn<a aria-hidden="true" tabindex="-1" class="hash-link" href="#scikit-learn" title="Direct link to heading">#</a></h3><p><code>import sklearn</code>
<strong>train_test_split</strong></p><ul><li><code>from sklearn.model_selection import train_test_split</code></li><li>Use stratified sampling to split up the dataset according to the categorical_y_data dataset<ul><li><code>X_train, X_test, y_train, y_test = train_test_split(data_x, categorical_y_data, stratify=categorical_y_data, test_size=&lt;0.0 - 1.0&gt;, random_state=seed)</code></li><li>Stratified: Make the distribution of each feature as close as possible to the original in the training and test sets</li><li>75% into training set and 25% into test set</li></ul></li></ul><p><strong>mean_squared_error</strong></p><ul><li><code>from sklearn.metrics import mean_squared_error</code></li><li><code>rmse = np.sqrt(mean_squared_error(y_test, y_pred))</code></li></ul><p><strong>Pipelines</strong></p><ul><li><code>from sklearn.pipeline import Pipeline</code></li><li>Usage: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">pipe = Pipeline([</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (&#x27;scaler&#x27;,StandardScaler()),              # 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (&#x27;reducer&#x27;, PCA()),                       # 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  (&#x27;classifier&#x27;, RandomForestClassifier())  # 2 (&#x27;SVM&#x27;, SVC()) | (&#x27;elasticnet&#x27;, ElasticNet())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># pipe.fit(Xtrain, ytrain)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># pipe.fit_transform(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># accessing the tuple (&#x27;scaler&#x27;, scaler_obj): pipe[0]</span></div></div></div></div></div><p><strong>Concepts</strong></p><p>Data Standardization (normalization):</p><ul><li>Preprocessing task performed on numerical, continuous data to <strong>make it normally distributed</strong>. Standardize (assuming linear space) when:<ul><li><ol><li>Using a model that is in a linear space (any kind of model that uses a linear distance metric or operates in a linear space like k-nearest neighbors, linear regression, or k-means clustering). The model is assuming that the data and features you&#x27;re giving it are related in a linear fashion, or can be measured with a linear distance metric. </li></ol></li><li><ol start="2"><li>When a feature or features in your dataset have high variance ; if a feature in your dataset has a variance that&#x27;s an order of magnitude or more greater than the other features, this could impact the model&#x27;s ability to learn from other features in the dataset. </li></ol></li><li><ol start="3"><li>When features are of different scales e.g. height &amp; weight. To compare these features, they must be in the same linear space, and therefore must be standardized in some way. </li></ol></li></ul></li><li><strong>StandardScaler</strong>: For Data Standardization<ul><li>Finds mean and centers data around it (no limit to max / min)</li><li><strong>Import</strong>: <code>from sklearn.preprocessing import StandardScaler</code></li><li><strong>Creation</strong>: <code>ss = StandardScaler()</code></li><li><strong>Fit</strong>: <code>ss.fit(training_df_column)</code> (Call before transform)<ul><li>only fit with training data to avoid data leakage (won&#x27;t have access to test data)</li></ul></li><li><strong>Normalize scale</strong>: <code>ss.transform(dataframe_subset (columns))</code><ul><li>transform training data</li><li>Use <code>.fit_transform(...)</code> to fit, then transform data</li></ul></li></ul></li><li><strong>scale</strong><ul><li>Same purpose as standardscalar</li><li><strong>Import</strong>: <code>from sklearn.preprocessing import scale</code></li><li><strong>Usage</strong>: <code>scaled_data = scale(data)</code></li></ul></li><li><strong>MinMaxScaling</strong>: For normalizing linear values to 0-1 by squashing min and max range to 0-1<ul><li>Use only when you know your data has a strict lower and upper bound</li><li><strong>Import</strong>: <code>from sklearn.preprocessing import MinMaxScaler</code></li><li><strong>Creation</strong>: <code>MM_scaler = MinMaxScaler()</code></li><li><strong>Fit</strong>: <code>MM_scaler.fit(training_df_column)</code> (Call before transform)<ul><li>only fit with training data</li></ul></li><li><strong>Transform</strong>: <code>resultantCol = MM_scaler.transform(training_df_column)</code><ul><li>transform training data</li><li>Use <code>.fit_transform(...)</code> to fit, then transform data</li></ul></li></ul></li><li><strong>Log transform</strong>: <ul><li><strong>Import</strong>: <code>from sklearn.preprocessing import PowerTransformer</code></li><li><strong>Creation</strong>: <code>pow_trans = PowerTransformer()</code></li><li><strong>Fit</strong>: <code>pow_trans.fit(training_df_column)</code> (Call before transform)<ul><li>only fit with training data</li></ul></li><li><strong>Normalize scale</strong>: <code>pow_trans.transform(dataframe_subset (columns))</code><ul><li>transform training data</li><li>Use <code>.fit_transform(...)</code> to fit, then transform data</li></ul></li></ul></li></ul><p>Data Sanitization</p><ul><li>Outlier Removal<ul><li>Quantile (percentage) based<ul><li><ol><li>Find quantile: <code>quantile = dataframe[&#x27;col&#x27;].quantile(0.95)</code></li></ol></li><li><ol start="2"><li>Trim: <code>trimmed_df = dataframe[dataframe[&#x27;col&#x27;] &lt; quantile]</code></li></ol></li></ul></li><li>standard dev based<ul><li>Get mean and std dev</li><li>Calculate cutoff e.g. <code>3 * std</code>, and lower (<code>mean - cutoff</code>) + upper (<code>mean + cutoff</code>) bounds</li><li>Trim outliers <code>df[(df[&#x27;col&#x27;] &lt; upper) &amp; (df[&#x27;col&#x27;] &gt; lower)]</code><ul><li><a href="https://towardsdatascience.com/5-ways-to-detect-outliers-that-every-data-scientist-should-know-python-code-70a54335a623" target="_blank" rel="noopener noreferrer">Detecting outliers</a></li></ul></li></ul></li></ul></li><li>Text preprocessing tricks<ul><li>Trim whitespace</li><li>Remove punctuation</li><li>Remove commonly occurring words or stopwords</li><li>Expanding contracted words (e.g. can&#x27;t)</li><li>Remove special characters such as numbers and emojis.</li><li>Done using <strong>tokenization</strong> (split corpus by space)</li><li>Done by <strong>lemmatization</strong> (convert word into base form e.g. &quot;eating&quot; &quot;ate&quot; into &quot;eat&quot;)</li></ul></li></ul><p>Feature Engineering</p><ul><li><p>Descript: Creation of new features from existing features (e.g. string/timestamp subsetting, aggregate numeric data across columns etc)</p></li><li><p><strong>LabelEncoder</strong>: Converting labelled column into {0,1} column</p><ul><li><strong>Creation</strong>: <code>enc = LabelEncoder()</code></li><li><strong>Encode as binary</strong>: <code>new_col = enc.fit_transform(dataframe[&#x27;col&#x27;])</code></li></ul></li><li><p><strong>One Hot Encoding</strong>: Convert column of categories into 2D binary array</p><ul><li>Do this instead of mapping categories to numbers, to avoid encoding ordering to the categories</li></ul></li><li><p><strong>Dummy Encoding</strong>: Same as one-hot encoding, but the first column dropped. Membership to the first column is indicated (implied) when all OHE are set to 0.</p><ul><li><strong>Both OHE &amp; Dummy use the same command:</strong></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">df_dummied = pd.get_dummies(dataframe,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    columns = [column_labels], </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    drop_first=True, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    prefix=&#x27;col_prefix&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div></li><li><p><strong>CountVectorizer</strong>: Vectorize text with word count</p><ul><li>Bag of words (BoW): Given a vocabulary e.g. [&#x27;a&#x27;,&#x27;sock&#x27;,&#x27;dog&#x27;], convert corpus into a dictionary counting number of times the words occur e.g. [0, 2, 1]</li><li><strong>Import</strong>: <code>from sklearn.feature_extraction.text import CountVectorizer</code></li><li><strong>Creation</strong>: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cv = CountVectorizer(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    lowercase = bool,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    stop_words = &#x27;english&#x27; # optional for excluding stop words in the BoW vector</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    min_df: 0-1,   # Use only words that occur in more than this percentage of documents. This can be used to remove outlier words that will not generalize across texts.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    max_df: 0-1,   # Use only words that occur in less than this percentage of documents. This is useful to eliminate very common words that occur in every corpus without adding value such as &quot;and&quot; or &quot;the&quot;.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ngram_range = (start&lt;min=1&gt;, stop) # don&#x27;t forget curse of dimensionality</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li><strong>Fit</strong>: <code>cv.fit(speech_df[&#x27;text_clean&#x27;])</code></li><li><strong>Get word list</strong>: <code>cv.get_feature_names()</code> </li><li><strong>Transform</strong>: <code>cv_transformed = cv.transform(speech_df[&#x27;text_clean&#x27;])</code><ul><li>returns sparse array</li><li><strong>To array</strong>: <code>cv_transformed.toarray()</code><ul><li>1 row per block of text and a column for each of the features generated by the vectorizer</li></ul></li></ul></li></ul></li><li><p><strong>tf-idf</strong>: Term Frequency - Inverse Document Frequency vector</p><ul><li>Descript: Text vectorization converts text to numerical input</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>t</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>â‹…</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mrow><mi>d</mi><msub><mi>f</mi><mi>i</mi></msub></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w_{i,j} = tf_{i,j} \cdot log(\frac{N}{df_i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">â‹…</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.3534389999999998em;vertical-align:-0.481108em"></span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em"><span style="top:-2.357em;margin-left:-0.10764em;margin-right:0.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em">N</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span><ul><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span></span></span></span></span>: weight of term i in document j</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">tf_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em"><span></span></span></span></span></span></span></span></span></span></span>: term frequency of i in j</li><li>N: # of documents in corpus</li><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">df_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>: # of documents containing term i</li></ul></li><li>[(# of word occurences) / (total words in document)] / log(# of docs word is in / total number of docs)<ul><li>Divide proportion of word occurence by proportion that it appears in all documents<ul><li>reduces value of common words</li></ul></li></ul></li><li><strong>Import</strong>: <code>from sklearn.feature_extraction.text import TfidfVectorizer</code></li><li><strong>Creation</strong>: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">tfidf_vec = TfidfVectorizer(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  max_features=n, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  stop_words=&#x27;english&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ngram_range = (start, stop) # Adding some ordering. bi-gram (&quot;not happy&quot;) tri-gram (&quot;never not happy&quot;). Tries to fix bag of words problem</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li><p>stop_words will remove common words like &#x27;the&#x27;</p></li><li><p><strong>Transform</strong>: <code>text_tfidf = tfidf_vec.fit_transform(title_text)</code></p><ul><li>returns sparse array</li><li><strong>To array</strong>: <code>cv_transformed.toarray()</code></li><li>Indices and weights will be stored in the tfidf vector <code>text_tfidf</code></li><li>Vocabulary and weights will be stored in the TfidfVectorizer <code>tfidf_vec</code>.</li><li>Example</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Instantiate TfidfVectorizer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tv = TfidfVectorizer(max_features=100, stop_words=&#x27;english&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Fit the vectroizer and transform the data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tv_transformed = tv.fit_transform(train_speech_df[&#x27;text_clean&#x27;])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Transform test data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">test_tv_transformed = tv.transform(test_speech_df[&#x27;text_clean&#x27;])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Create new features for the test set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">test_tv_df = pd.DataFrame(test_tv_transformed.toarray(), </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                          columns=tv.get_feature_names()).add_prefix(&#x27;TFIDF_&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(test_tv_df.head())</span></div></div></div></div></div><ul><li><strong>Get word list</strong>: <code>cv.get_feature_names()</code> </li><li><strong>Get word to index map</strong>: <code>str_idx_map = tfidf_vec.vocabulary_</code><ul><li><strong>Get index to word map</strong>: <code>idx_str_map = {v:k for k,v in tfidf_vec.vocabulary_.items()}</code></li></ul></li><li><strong>Get weights for every word in row</strong>: <code>text_tfidf[row_index].data</code><ul><li>If row_index is not number, use <code>iloc[n]</code></li></ul></li><li><strong>Get indices for every word in row</strong>: <code>text_tfidf[row_index].indices</code><ul><li><strong>Get indices to weights map for row</strong>: <code>idx_wgts_map = dict( zip(text_tfidf[row_index].indices, text_tfidf[row_index].data)</code><ul><li><strong>Get word to weights map for row</strong>: <code>str_wgts_map = {idx_str_map[i]:idx_wgts_map[i] for i in text_tfidf[row_index].indices}</code></li></ul></li></ul></li><li><strong>Get indices of top n weights</strong>: <code>top_n_idx = pd.Series(str_wgts_map).sort_values(ascending=False)[:top_n].index</code></li><li><strong>Get words of top n weights</strong>: <code>top_n_str = [idx_str_map[i] for i in top_n_idx]</code></li></ul></li></ul></li><li><p>Word Embeddings: Comparing not just the word frequencies, but the meanings of each word</p><ul><li>Use spacy</li></ul></li></ul><p>Feature Selection</p><ul><li>Removing <strong>redundant</strong> (noisy|correlated|duplicated) features.<ul><li>e.g. features that generated an aggregate statistic</li></ul></li><li><strong>t-SNE</strong>: t-Distributed Stochastic Neighbour Embedding. <ul><li>Used to significantly reeduce dimensions of a dataset, so you can visually explore the patterns in a high dimensional dataset.</li><li><code>from sklearn.manifold import TSNE</code></li><li><strong>Init</strong>: <code>m = TSNE(learn_rate_eg_50)</code></li><li><strong>Fit &amp; Transform</strong>: <code>tsne_features = m.fit_transform(df_numeric)</code></li></ul></li><li><strong>To avoid overfitting</strong>: &quot;number of observations should increase exponentially with the number of features&quot;<ul><li>Too few observations: model overfits by memorizing the test data</li><li>Curse of dimensionality: when the number of observations is too high to satisfy</li></ul></li></ul><p>Feature Extraction</p><ul><li>Transform data into new features</li><li><strong>Dimensionality Reduction</strong>: Reduce feature space<ul><li>Turning numericals into binned vals / binary</li><li><strong>Feature selection:</strong> Drop irrelevant features</li><li><ol><li>Remove redundant features (columns) where variance too small</li></ol><ul><li><ol><li><code>from sklearn.feature_selection import VarianceThreshold</code></li></ol></li><li><ol start="2"><li><code>sel = VarianceThreshold(threshold=0.005)</code></li></ol></li><li><ol start="3"><li>Normalize variance for all columns: <code>norm_df = df / df.mean()</code></li></ol></li><li><ol start="4"><li>Fit VarianceThreshold: <code>sel.fit(norm_df)</code></li></ol></li><li><ol start="5"><li>Get mask: <code>mask = sel.get_support()</code></li></ol></li><li><ol start="6"><li>Get columns with variance at least 0.005: <code>df.loc[:, mask]</code></li></ol><ul><li>0.005 not fixed; check the variances of your features before truncating</li></ul></li></ul></li><li><ol start="2"><li>Remove features that are strongly correlated or duplicated</li></ol><ul><li><ol><li>Get corr matrix (abs): <code>corr = df.corr().abs()</code></li></ol></li><li><ol start="2"><li>Create True/False mask for upper triangle: <code>mask = np.triu(np.ones_like(corr, dtype=bool))</code></li></ol></li><li><ol start="3"><li>Visualize with mask: <code>sns.heatmap(df.corr(), mask=mask, cmap=cmap, center=0, linewidths=1, annot=True, fmt=&quot;.2f&quot;); plt.show()</code></li></ol></li><li><ol start="4"><li>Apply T/F mask; replace sections that are True with NAN: <code>tri_df = corr_matrix.mask(mask)</code></li></ol></li><li><ol start="5"><li>Get cols that are highly correlated: <code>to_drop = [c for c in tri_df.columns if any(tri_df[c] &gt;  0.95)]</code></li></ol></li><li><ol start="6"><li>Drop: <code>reduced_df = df.drop(to_drop, axis=1)</code></li></ol></li></ul></li><li><ol start="3"><li>Remove features with too many missing values</li></ol><ul><li><code>mask = school_df.isna().sum() / len(school_df) &lt; 0.5</code></li><li><code>reduced_df = df.loc[:, mask]</code></li></ul></li><li><ol start="4"><li><strong>Recursive Feature Elimination</strong>: Remove features that have little effect on prediction (by seeing its weights)</li></ol><ul><li><code>from sklearn.feature_selection import RFE</code></li><li>Init: <code>rfe = RFE(estimator=LogisticRegression(), n_features_to_select=3, verbose=1, step=n_features_to_drop_per_iter)</code><ul><li>Other estimators: <code>RandomForestClassifier(), GradientBoostingRegressor()</code></li></ul></li><li>Fit: <code>rfe.fit(X_train, y_train)</code></li><li>Columns ranked (highest = weakest): <code>print(dict(zip(X.columns, rfe.ranking_)))</code></li><li>Columns kept (<code>rfe.support_</code> is a mask): <code>print(X.columns[rfe.support_])</code></li><li>Test (using accuracy_score): <code>accuracy_score(y_test, rfe.predict(X_test))</code></li></ul></li><li><strong>Feature Extraction:</strong> Combine features</li><li><ol><li><strong>Principle Component Analysis (PCA)</strong>: linear transformation to uncorrelated space</li></ol><ul><li><img src="/My-Docs/assets/images/pca-36cea45e68e6bdc68fd9f5be6c2d29bc.jpg"></li><li>Change basis: 1 to represent variance (yellow vector), 1 to represent magnitude (red vector). Can be used to represent each point. Coordinates in this new reference system are called <strong>principle components</strong>.</li><li>Vectors ranked by importance based on how well they explain variance (e.g.the red one would be most important as it best explains the variance)</li><li>Variance captured in a meaningful way by combining features into components</li><li>Number of components = number of input features</li><li>Difficult to interpret components, should be left to the end-of-preprocessing journey</li><li><strong>Creation</strong>: <code>pca = PCA(n_components=num_or_variance_ratio)</code></li><li><strong>Transform</strong>: <code>transformed_X = pca.fit_transform(dataframe_X)</code></li><li><strong>Revert transformation</strong>: <code>reverted_data = pca.inverse_transform(transformed_X)</code><ul><li>Good for compressing / decompressing information, but lossy</li></ul></li><li><strong>Components</strong> (vectors of weightage per feature): <code>pca.components_</code></li><li><strong>How much variance is explained by each component</strong>: <code>pca.explained_variance_ratio_</code></li><li><strong>Tagging component to column</strong>: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">vectors = pipe.steps[1][1].components_.round(2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Print feature effects</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(&#x27;PC 1 effects = &#x27; + str(dict(zip(poke_df.columns, vectors[0]))))</span></div></div></div></div></div></li></ul></li><li>POS tagging (Parts of Speech) (e.g. Pronoun, verb, article, noun)</li><li>Named Entity Recognition (NER) (e.g. Person, Organization)</li></ul><p>Models</p><p><strong>K-Nearest Neighbour (KNN)</strong> Classifier. <a href="https://www.datacamp.com/community/tutorials/k-nearest-neighbor-classification-scikit-learn" target="_blank" rel="noopener noreferrer">See</a></p><ul><li>See also <a href="https://www.analyticsvidhya.com/blog/2018/08/k-nearest-neighbor-introduction-regression-python/" target="_blank" rel="noopener noreferrer">what</a> and <a href="https://stats.stackexchange.com/questions/104255/why-would-anyone-use-knn-for-regression" target="_blank" rel="noopener noreferrer">why</a> and <a href="https://www.fromthegenesis.com/pros-and-cons-of-k-nearest-neighbors/" target="_blank" rel="noopener noreferrer">pros/cons</a></li><li>Return label of closest neighbour as prediction</li><li><strong>Import</strong>: <code>from sklearn.neighbors import KNeighborsClassifier</code></li><li><strong>Create</strong>: <code>knn = KNeighborsClassifier(n_neighbors=3)</code><ul><li>You can iterate through the # of neighbors to find the best fit</li></ul></li><li><strong>Training</strong>: <code>knn.fit(X_train (features), y_train (labels))</code></li><li><strong>Scoring</strong>: <code>knn.score(X_test, y_test)</code></li><li><strong>Predict</strong>: <code>predicted = knn.predict(input)</code></li></ul><p><strong>Naive Bayes</strong> Classifier: </p><ul><li>Assumes features are independent, works well with high-dimensional text data</li><li><strong>Training</strong>: <code>nb.fit(X_train (features), y_train (labels))</code></li><li><strong>Scoring</strong>: <code>nb.score(X_test, y_test)</code></li><li><strong>Predict</strong>: <code>predicted = nb.predict(input)</code></li></ul><p><strong>Multinomial Naive Bayes</strong> classifier (0 or 1):</p><ul><li>Init: <code>clf = MultinomialNB()</code></li><li>Fit: <code>clf.fit(X_train_BoW, y_train)</code></li><li>Scoring: <code>accuracy = clf.score(X_test_bow, y_test)</code></li><li>Prediction example: </li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Predict the sentiment of a negative review</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">review = &quot;The movie was terrible. The music was underwhelming and the acting mediocre.&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">prediction = clf.predict(vectorizer.transform([review]))[0]</span></div></div></div></div></div><p><strong>Support Vector Classifier</strong></p><ul><li><code>from sklearn.svm import SVC</code></li><li><code>from sklearn.metrics import accuracy_score</code></li><li>Init: <code>svc = SVC()</code></li><li>Fit: <code>svc.fit(X_train, y_train)</code></li><li>Scoring: <code>accuracy = accuracy_score(y_test, svc.predict(X_test))</code></li><li>Check overfit: <code>accuracy_train = accuracy_score(y_train, svc.predict(X_train))</code></li></ul><p><strong>Logistic Regression</strong></p><ul><li>Features need to be scaled first using standardscaler</li><li>Init: <code>lr = LogisticRegression()</code></li><li>Fit: <code>lr.fit(X_train_std, y_train)</code></li><li>Predict: <code>y_pred = lr.predict(X_test_std)</code></li><li>Predict (probability of 1): <code>proba_1 = logreg.predict_proba(X_test_std)</code></li><li>Weights: <code>print(dict(zip(X.columns, abs(lr.coef_[0]).round(2))))</code></li></ul><p><strong>Random Forest Classifier</strong></p><ul><li>Algorithm to calculate feature importance by averaging how often features are used to make decisions in multiple random decision trees</li><li>Init: <code>rf = RandomForestClassifier()</code></li><li>Fit: <code>rf.fit(X_train, y_train)</code></li><li>Predict Accuracy: <code>acc = accuracy_score(y_test, rf.predict(X_test))</code></li><li>Get feature importances mask: <code>mask = rf.feature_importances_ &gt; 0.1</code><ul><li>Select by mask: <code>df.loc(:, mask)</code></li></ul></li><li>Use with RFE: `RFE(estimator=RandomForestClassifier(), ...)</li></ul><p><strong>Linear Regression</strong></p><ul><li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>c</mi><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>w</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y = c + w_1x_1 + w_2x_2 + ... w_nx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> + error</li><li><code>from sklearn.linear_model import LinearRegression</code></li><li>init: <code>lr = LinearRegression</code></li><li>fit: <code>lr.fit(X_train, y_train)</code></li><li>coefficients (<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>): <code>lr.coef_</code></li><li>How it works:<ul><li>Minimize loss function: Mean Squared Error (MSE)</li><li>Avoid overfitting by using <strong>regularization</strong>: goal is to keep model simple by keeping coefficients low<ul><li>Regularization term: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î±</mi><mo stretchy="false">(</mo><mi mathvariant="normal">âˆ£</mi><msub><mi>Î²</mi><mn>1</mn></msub><mi mathvariant="normal">âˆ£</mi><mo>+</mo><mi mathvariant="normal">âˆ£</mi><msub><mi>Î²</mi><mn>2</mn></msub><mi mathvariant="normal">âˆ£</mi><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">âˆ£</mi><msub><mi>Î²</mi><mi>n</mi></msub><mi mathvariant="normal">âˆ£</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha (|\beta_1| + |\beta_2| + ... |\beta_n|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.0037em">Î±</span><span class="mopen">(</span><span class="mord">âˆ£</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em">Î²</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">âˆ£</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">âˆ£</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em">Î²</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">âˆ£</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">âˆ£</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em">Î²</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">âˆ£</span><span class="mclose">)</span></span></span></span></span></li><li>Alpha: trade-off between overfitting and keeping model simple. Too low = overfit, Too high = inaccurate model</li><li>Final regularized expression: <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>c</mi><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>w</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y = c + w_1x_1 + w_2x_2 + ... w_nx_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> + error + regularization_term</li><li><strong>Lasso</strong>: 1 linear regression model that uses regularization</li><li><code>from sklearn.linear_model import Lasso</code></li><li>Ensure X_data is standardized using StandardScaler</li><li>Init: <code>la = Lasso(alpha={0.0-1.0}, random_state={0,1}, normalize=bool)</code><ul><li>Recall that in regression regularization, alpha here refers to the weight of the regularization term</li></ul></li><li>Fit: <code>la.fit(X_train_std, y_train)</code></li><li>coeffs: <code>la.coef_ </code></li><li>score (R squared): <code>la.score(X_test_std, y_test)</code></li><li><strong>LassoCV</strong>: Cross Validation to find optimal alpha value (Same syntax as above)</li><li><strong>Ridge</strong>: Another regressor like Lasso, but supposedly better</li><li>Init: Same syntax</li><li>You can modify the alpha on the fly using <code>ridge.alpha = a</code></li><li><code>from sklearn.linear_model import Ridge</code></li></ul></li></ul></li></ul><p><strong>Confusion Matrix</strong></p><ul><li>Generate table of [0,0]: True Positive, [0,1]: False Negative, [1,0]: True Negative, [1,1]: False Positive</li><li>Import: <code>from sklearn.metrics import confusion_matrix</code></li><li>Import: <code>from sklearn.metrics import classification_report</code></li><li>Init: </li></ul><p>Comparing similarity between vectors</p><p><strong>Cosine Similarity</strong>:</p><ul><li><code>from sklearn.metrics.pairwise import cosine_similarity</code></li><li>Ratio of (dot product of vectors) and (product of magnitude of vectors)</li><li>Range of values from -1 to 1, but since NLP vectors are non-neg, it&#x27;s 0 - 1</li><li>Calcualting <strong>pairwise</strong> cosine similarity matrix: <code>cosine_similarity(A, B)</code> e.g. <code>cosine_similarity(tfidf_mat, tfidf_mat)</code><ul><li>A and B can be the same <code>tfidf_matrix = tfidf_vectorizer.fit_transform(corpus)</code> if you want to check similiarity across entries</li></ul></li><li>When comparing tf-idf vectors, their magnitude is 1, so use <code>linear_kernel</code></li><li><code>from sklearn.metrics.pairwise import linear_kernel</code></li></ul><p>Bootstrap</p><ul><li>Given a sample of data, resample from this data<ul><li><strong>Bootstrap sample</strong>: array of resampled data</li><li><strong>Bootstrap replicate</strong>: summary statistics (e.g. mean) of this array of resampled data</li><li>You can resample using <code>np.random.choice(..)</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="verifying-model-accuracy"></a>Verifying model accuracy<a aria-hidden="true" tabindex="-1" class="hash-link" href="#verifying-model-accuracy" title="Direct link to heading">#</a></h2><p>n-fold Cross-validation</p><ul><li>Concept:<ul><li>Split data into n chunks (referred to as &quot;folds&quot;)</li><li>Train on (n-1) chunks, test on the last chunk</li><li>Repeat this procedure n times (refresh the model each time), each time testing with a different chunk</li><li>Gather all the R^2 values from these tests to build mean, var and confidence interval of R^2</li></ul></li><li>Import: <code>from sklearn.model_selection import cross_val_score</code></li><li>Usage: <code>cv_scores_array = cross_val_score(LinearRegression(), X, y, cv=n)</code><ul><li>you can replace <code>LinearRegression()</code> with other models such as <code>Ridge()</code></li><li>you can also get the mean cv_scores by <code>np.mean()</code></li></ul></li></ul><p>ROC curve</p><ul><li>ROC: y: True Positive Rate / x: False Positive Rate</li><li>Precision: TP/(TP+FP)</li><li>Recall:    TP/(TP+FN)</li><li>Import: <code>from sklearn.metrics import roc_curve</code>, <code>from sklearn.metrics import roc_auc_score</code></li><li>Plotting ROC curve:</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute predicted probabilities: y_pred_prob</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">y_pred_prob = logreg.predict_proba(X_test)[:,1]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Generate ROC curve values: fpr, tpr, thresholds</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fpr, tpr, thresholds = roc_curve(y_test, y_pred_prob)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Plot ROC curve</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.plot([0, 1], [0, 1], &#x27;k--&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.plot(fpr, tpr)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.xlabel(&#x27;False Positive Rate&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.ylabel(&#x27;True Positive Rate&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.title(&#x27;ROC Curve&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">plt.show()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># AUC: Area Under Curve</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute and print AUC score</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(&quot;AUC: {}&quot;.format(roc_auc_score(y_test, y_pred_prob)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute cross-validated AUC scores: cv_auc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cv_auc = cross_val_score(logreg, X, y, cv=5, scoring=&#x27;roc_auc&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Print list of AUC scores</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(&quot;AUC scores computed using 5-fold cross-validation: {}&quot;.format(cv_auc))</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="hyperparam-tuning"></a>Hyperparam Tuning<a aria-hidden="true" tabindex="-1" class="hash-link" href="#hyperparam-tuning" title="Direct link to heading">#</a></h2><ul><li><strong>GridSearchCV</strong>: iterate through all the possible hyperparams and then choosing the best</li><li>import: <code>from sklearn.model_selection import GridSearchCV</code></li><li>Init: <code>logreg_cv = GridSearchCV(LogisticRegression()/pipeline, param_grid, cv=5)</code><ul><li>Hyperparam grid: <code>param_grid = {&#x27;stepName__param&#x27;: np.logspace(-5, 8, 15)}</code></li><li>There are many classifiers such as ElasticNet.</li></ul></li><li>Create hold-out set: <code>X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.4, random_state=42)</code><ul><li>Hold-out set: split training/test set even before doing searchCV; makes sure that the model generalizes well to unknown data</li></ul></li><li>Fit Searcher to data: <code>logreg_cv.fit(X_train,y_train)</code></li><li>Get best params (classifier l1 ratio): <code>logreg_cv.best_params_</code></li><li>Get score of best params: <code>logreg_cv.best_score_</code></li><li>Get r2: <code>logreg_cv.score(X_test, y_test)</code></li><li>Get MSE: <code>mse = mean_squared_error(y_test, logreg_cv.predict(X_test))</code></li><li><strong>RandomSearchCV</strong>: same concept and syntax as above (fit, then best<em>params</em>), for larger search spaces<ul><li><code>from sklearn.model_selection import RandomizedSearchCV</code></li><li>Init: <code>tree_cv = RandomizedSearchCV(DecisionTreeClassifier(), param_dist, cv=5)</code><ul><li><code>param_dist = {&quot;max_depth&quot;: [3, None],&quot;max_features&quot;: randint(1, 9), &quot;min_samples_leaf&quot;: randint(1, 9), &quot;criterion&quot;: [&quot;gini&quot;, &quot;entropy&quot;]}</code></li></ul></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="imputer-impute-missing-info"></a>Imputer (Impute missing info)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#imputer-impute-missing-info" title="Direct link to heading">#</a></h3><ul><li><code>from sklearn.preprocessing import Imputer</code></li><li>Purpose: preprocessing data</li><li>Init: <code>Imputer(missing_values=&#x27;NaN&#x27;, strategy=&#x27;most_frequent|mean&#x27;, axis=0|1</code><ul><li>axis: is_row </li></ul></li><li>As part of pipeline: <code>steps = [(&#x27;imputation&#x27;, initialized_imputer),...]</code><ul><li><code>pipe = Pipeline(steps)</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="numpy"></a>Numpy<a aria-hidden="true" tabindex="-1" class="hash-link" href="#numpy" title="Direct link to heading">#</a></h2><ul><li><p><strong>Import</strong>: <code>import numpy as np</code></p></li><li><p><strong>Numpy Array</strong></p><ul><li>Creation<ul><li><strong>Create array</strong>: <code>np.array(list)</code></li><li><strong>Create empty</strong>: <code>np.empty(shape)</code></li><li><strong>Create empty like</strong>: <code>np.empty_like(list)</code></li></ul></li><li>Attributes<ul><li><strong>Shape</strong>: <code>np_list.shape</code></li></ul></li><li>Unary Operations<ul><li><strong>Transpose array</strong>: <code>np.transpose(list)</code></li><li><strong>Reshape</strong>: <code>np.reshape(np_array, (new, shape, dimensions))</code>. <a href="https://numpy.org/doc/stable/reference/generated/numpy.reshape.html" target="_blank" rel="noopener noreferrer">Doc</a></li></ul></li><li>Operation with scalar<ul><li><strong>Slicing 2D numpy array (get row / get col)</strong>: <code>np_2d[row,:]</code>, <code>np_2d[:,col]</code></li><li><strong>Mass multiplication</strong>: <code>np_list *= val</code></li><li><strong>Iterate 2D array as 1D</strong>: <code>for x in np.nditer(np_2d_arr)</code></li></ul></li><li>Operations involving two numpy arrays<ul><li><strong>Mass operation</strong>: <code>np_list3 = np_list1 / np_list2</code></li><li><strong>Union</strong>: <code>np.logical_and(arr1, arr2)</code></li><li><strong>Intersect</strong>: <code>np.logical_or(a1,a2)</code></li><li><strong>Negation of numpy arr</strong>: <code>np.logical_not(a1,a2)</code></li><li><strong>Concat</strong>: <code>np.concatenate([list1, list2,...])</code></li></ul></li><li>Operations involving boolean arrays<ul><li><strong>Generate boolean array by applying condition to array</strong>: <code>bool_val = np_list &gt; val</code></li><li><strong>Subsetting with bool array</strong>: <code>np_list[bool_val]</code></li></ul></li><li>Aggregation Operations<ul><li><strong>Mean</strong>: <code>np.mean(np_list)</code></li><li><strong>Median</strong>: <code>np.median(np_list)</code></li><li><strong>Std Dev</strong>: <code>np.std(np_list)</code><ul><li><strong>Standard Error (of the mean)</strong>: <code>np.std(data) / np.sqrt(len(data))</code><ul><li>&quot;Standard deviation (SD) measures the dispersion of a dataset relative to its mean.&quot;</li><li>&quot;Standard error of the mean (SEM) measured how much discrepancy there is likely to be in a sample&#x27;s mean compared to the population mean.&quot;</li><li><a href="https://www.investopedia.com/ask/answers/042415/what-difference-between-standard-error-means-and-standard-deviation.asp" target="_blank" rel="noopener noreferrer">See more</a></li></ul></li></ul></li><li><strong>Variance</strong>: <code>np.var(np_list)</code></li><li><strong>Covariance Matrix</strong>: <code>np.cov(np_list1, np_list2)</code><ul><li>[0,0]: x.var(), [1,1]: y.var(), [0,1] = [1,0]: covariance</li><li>mean of the distances from the mean (negative or positive, showing how correlated x and y are)</li><li><img src="/My-Docs/assets/images/covariance-66ba702f083d4e255fbf35141322a4cc.jpg"></li></ul></li><li><strong>Pearson Correlation Coefficient</strong>: <code>np.corrcef(np_list1, np_list2)</code><ul><li><ul><li>[0,0]: 1, [1,1]: 1, [0,1]: correlation coeff</li></ul></li><li>covariance / (x.std * y.std)</li><li>variability due to codependence / (interpendent variability)</li></ul></li></ul></li></ul></li><li><p><strong>Numpy Random</strong></p><ul><li><strong>Init with Seed</strong>: <code>np.random.seed(seed)</code></li><li><strong>Generate Float</strong> 0-1: <code> np.random.random()</code></li><li><strong>Generate Integer</strong>: <code>np.random.randint(lowerIncl, upperExcl)</code></li><li><strong>Binomial</strong>: <code>np.random.binomial(n, p, size=sample_size)</code></li><li><strong>Poisson</strong>: <code>np.random.poisson(mean, size=sample_size)</code></li><li><strong>Exponential</strong>: <code>np.random.exponential(mean, size=sample_size)</code>  </li><li><strong>Normal Distribution</strong>: <code>np.random.normal(mean, std, size=sample_size)</code><ul><li>tails are very unlikely; real datasets can have extreme outliers, normal distribution may not be best descriptor for data</li></ul></li><li><strong>Permutate (shuffle)</strong>: <code>np.random.permutate(list)</code><ul><li>If we can assume that two samples (e.g. Ohio and PA) share the same distribution, then we can <code>concatenate</code> them, permutate (shuffle), then split the samples into the same sizes to get new samples. These are called <strong>permutation samples</strong></li></ul></li></ul></li><li><p><strong>Numpy Definitions</strong></p><ul><li><strong>NaN</strong>: <code>np.nan</code></li></ul></li><li><p><strong>Numpy Operations</strong></p><ul><li><p><strong>Cumulative Sum</strong>: <code>np.cumsum(list)</code></p></li><li><p><strong>Log10</strong>: <code>np.log10(nd_arr or dataframe)</code></p></li><li><p><strong>1D interpolation</strong>: <a href="https://numpy.org/doc/stable/reference/generated/numpy.interp.html" target="_blank" rel="noopener noreferrer">doc</a></p></li><li><p><strong>Calculate Percentiles</strong>: <code>np.percentile(np_data, np_array_of_percentiles_zero_to_hundrd)</code></p><ul><li>e.g. 95% confidence interval: <code>np.percentile(data, [2.5, 97.5])</code></li><li><strong>Confidence Interval</strong>: draw_bs_reps,then take percentile</li></ul></li><li><p><strong>Generate range as list</strong>: <code>numpy.arange([start=0, ]stop, [step=1])</code></p></li><li><p><strong>least squares</strong>: <code>slope, intercept = np.polyfit(x, y, deg_of_poly_to_fit&lt;1&gt;)</code></p></li><li><p><strong>Bootstrap samping (resampling with replacement)</strong>: <code>np.random.choice(arr_data, size=n)</code></p><ul><li>Imagine this as t-test but simulate by resampling <a href="https://stats.stackexchange.com/questions/128987/why-would-i-want-to-bootstrap-when-computing-an-independent-sample-t-test-how#:~:text=Both%20the%20t%2Dtest%20and,of%20the%20test%20statistic%20is.&amp;text=The%20advantage%20of%20the%20bootstrap,assumptions%20needed%20by%20parametric%20methods." target="_blank" rel="noopener noreferrer">See also</a></li><li><strong>Pairs Bootstrap</strong>: resample with replacement x and y coords. that cannot be separated</li><li><strong>Hypothesis testing</strong>:</li><li>Compute mean of combined data set, Shift the samples, Get bootstrap replicates of shifted data sets, Compute replicates of difference of means: bs_diff_replicates, Compute the p-value</li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Helper functions used in datacamp</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def bootstrap_replicate_1d(data, func):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Generate bootstrap replicate of 1D data.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bs_sample = np.random.choice(data, len(data))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return func(bs_sample)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def draw_bs_reps(data, func, size=1):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Draw bootstrap replicates.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Initialize array of replicates: bs_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bs_replicates = np.empty(size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Generate replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for i in range(size):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_replicates[i] = bootstrap_replicate_1d(data, func)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return bs_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def draw_bs_pairs_linreg(x, y, size=1):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Perform pairs bootstrap for linear regression.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Set up array of indices to sample from: inds</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    inds = np.arange(0, len(x))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Initialize replicates: bs_slope_reps, bs_intercept_reps</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bs_slope_reps = np.empty(size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bs_intercept_reps = np.empty(size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Generate replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for i in range(size):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_inds = np.random.choice(inds, size=len(inds))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_x, bs_y = x[bs_inds], y[bs_inds]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, 1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return bs_slope_reps, bs_intercept_reps</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def draw_bs_pairs(x, y, func, size=1):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Perform pairs bootstrap for a single statistic.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Set up array of indices to sample from: inds</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    inds = np.arange(len(x))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Initialize replicates: bs_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bs_replicates = np.empty(size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Generate replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for i in range(size):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_inds = np.random.choice(inds, len(inds))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_x, bs_y = x[bs_inds], y[bs_inds]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        bs_replicates[i] = func(bs_x, bs_y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return bs_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def permutation_sample(data1, data2):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Generate a permutation sample from two data sets.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Concatenate the data sets: data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    data = np.concatenate([data1, data2])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Permute the concatenated array: permuted_data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    permuted_data = np.random.permutation(data)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Split the permuted array into two: perm_sample_1, perm_sample_2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perm_sample_1 = permuted_data[:len(data1)]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perm_sample_2 = permuted_data[len(data1):]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return perm_sample_1, perm_sample_2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def draw_perm_reps(data_1, data_2, func, size=1):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;&quot;&quot;Generate multiple permutation replicates.&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Initialize array of replicates: perm_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    perm_replicates = np.empty(size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for i in range(size):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        # Generate permutation sample</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        perm_sample_1, perm_sample_2 = permutation_sample(data_1, data_2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        # Compute the test statistic</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        perm_replicates[i] = func(perm_sample_1, perm_sample_2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return perm_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># In null hypothesis significance testing, the p-value[note 1] is the probability of obtaining test results at least as extreme as the results actually observed, under the assumption that the null hypothesis is correct.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># https://en.wikipedia.org/wiki/P-value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def p_value(new_samples, true_value):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return np.sum(new_samples &lt;= true_value) / 10000</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># One-sample bootstrap hypothesis test example from datacamp</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Make an array of translated impact forces: translated_force_b</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">translated_force_b = force_b + (0.55 - force_b.mean())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Take bootstrap replicates of Frog B&#x27;s translated impact forces: bs_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bs_replicates = draw_bs_reps(translated_force_b, np.mean, 10000)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute fraction of replicates that are less than the observed Frog B force: p</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">p = np.sum(bs_replicates &lt;= np.mean(force_b)) / 10000</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Print the p-value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(&#x27;p = &#x27;, p)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Two-sample bootstrap hypothesis test example from datacamp</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute mean of all forces: mean_force</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mean_force = forces_concat.mean()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Generate shifted arrays</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">force_a_shifted = force_a - np.mean(force_a) + mean_force</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">force_b_shifted = force_b - np.mean(force_b) + mean_force </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute 10,000 bootstrap replicates from shifted arrays</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bs_replicates_a = draw_bs_reps(force_a_shifted, np.mean, 10000)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bs_replicates_b = draw_bs_reps(force_b_shifted, np.mean, 10000)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Get replicates of difference of means: bs_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bs_replicates = bs_replicates_a - bs_replicates_b</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute and print p-value: p</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">p = np.sum(bs_replicates &gt; empirical_diff_means) / 10000</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">print(&#x27;p-value =&#x27;, p)</span></div></div></div></div></div></li><li><p><strong>A/B Testing</strong>: Hypothesis testing, but testing the difference</p></li></ul><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Compute the observed difference in mean inter-no-hitter times: nht_diff_obs</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nht_diff_obs = diff_of_means(nht_dead, nht_live)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"># Acquire 10,000 permutation replicates of difference in mean no-hitter time: perm_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">perm_replicates = draw_perm_reps(nht_dead, nht_live, diff_of_means, 10_000)</span></div></div></div></div></div></li></ul><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="compute-and-print-the-p-value-p"></a>Compute and print the p-value: p<a aria-hidden="true" tabindex="-1" class="hash-link" href="#compute-and-print-the-p-value-p" title="Direct link to heading">#</a></h1><p>  p = np.sum(perm_replicates &lt;= nht_diff_obs) / 10000
print(&#x27;p-val =&#x27;, p)</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="your-p-value-is-00001-which-means-that-only-one-out-of-your-10000-replicates-had-a-result-as-extreme-as-the-actual-difference-between-the-dead-ball-and-live-ball-eras-this-suggests-strong-statistical-significance-"></a>&quot;Your p-value is 0.0001, which means that only one out of your 10,000 replicates had a result as extreme as the actual difference between the dead ball and live ball eras. This suggests strong statistical significance. &quot;<a aria-hidden="true" tabindex="-1" class="hash-link" href="#your-p-value-is-00001-which-means-that-only-one-out-of-your-10000-replicates-had-a-result-as-extreme-as-the-actual-difference-between-the-dead-ball-and-live-ball-eras-this-suggests-strong-statistical-significance-" title="Direct link to heading">#</a></h1><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Hypothesis Testing for correlation**:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Do a permutation test: Permute the x values but leave the y values fixed to generate a new set of (x,y) data. It is exact because it uses all data and eliminates any correlation because which x value pairs to which y value is shuffled.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ```</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Compute observed correlation: r_obs</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  r_obs = pearson_r(x, y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Initialize permutation replicates: perm_replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  perm_replicates = np.empty(10000)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Draw replicates</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for i in range(10000):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # Permute illiteracy measurments: x_permuted</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      x_permuted = np.random.permutation(x)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      # Compute Pearson correlation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      perm_replicates[i] = pearson_r(x_permuted, y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Compute p-value: p</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  p = np.sum(perm_replicates &gt;= r_obs) / len(perm_replicates)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  print(&#x27;p-val =&#x27;, p)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ```</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Interpolation:** `np.interp(xcoords_to_interpolate, data_xcoords, data_ycoords, left=None, right=None, period=None)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Generate uniformly spaced list**: `np.linspace(lower_lim, upper_lim, number_of_items)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Meshgrid: create a grid by using coordinates of each dimension**: `np.meshgrid(columns, rows)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* [See](https://stackoverflow.com/a/42404323)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">## Pandas</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Import**: `import pandas as pd`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#### Series (Pandas labelled list)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **From list**: `pd.Series(array, ..., index=arr)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#### DataFrame (Pandas labelled excel sheets / dictionaries)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Creation / Conversion</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **From Dictionary**: ```pd.DataFrame(dict)```</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **From CSV File**: </span></div></div></div></div></div><p>  dataframe = pd.read_csv(string_filename,
delimiter   = str,          # The shorthand &#x27;sep&#x27; serves the same purpose
header      = line_no_start_of_data,
index_col   = i, # Column to use as row labels of the df. Set to False to force pandas not to use the first column as the index, or to a col name if you want to use that col</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  [chunksize   = n, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  names       = new_col_labels_list, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  comment     = str_prefix, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  parse_dates = [date_col...]</span></div></div></div></div></div><p>  )</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Note that dataframes are iterables, so you can use &quot;next(iterable)&quot; on them (to get them in the chunksize)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Converting to set**: `set(df[&#x27;col&#x27;])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **add_prefix to all cols**: `df.add_prefix(str)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Accessing / Selection</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **For Loop for each row** (note that row is a dataframe / dictionary)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* `for idx, row in df.iterrows(): ...`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Slicing</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Get column as Series**: `dataframe[&quot;column&quot;]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Convert series to numpy.ndarray**: `series.values`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * Useful for getting data into right format for sklearn</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Extract columns from DF**: `dataframe[[&quot;column&quot;,...]]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Dataframe as rows**: `dataframe[startIdxIncl: endIdxExcl]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Array based selection</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Select by label**: </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `dataframe.loc[label]` (transposed / series / numpy array)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `dataframe.loc[[rowLbl1, rowLbl2..* .],[colLbl1, colLbl2...]]` (tabular / dataframe)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Select by index, not name**: Replace loc with iloc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `df.iloc[&lt;slicing for row&gt;, &lt;slicing for column&gt;]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Select all rows by column**: Replace label with &#x27;:&#x27; </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `dataframe.loc[&lt;slicing for row&gt;, &lt;slicing for column&gt;]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `dataframe.loc[:,col]` (Returns numpy array)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `dataframe.loc[:,* [cols]]` (Returns Dataframe)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **MultiIndexes**: `df.loc[(top_lvl_idx,2nd_lvl_idx,...), &lt;slicing for column&gt;]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * e.g. `sales.loc[(&#x27;NY&#x27;,1),:], sales.loc[(slice(None),2),:]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * If you have to use `:` for slicing, replace the tuple with `pd.IndexSlice[top_lvl_idx,2nd_lvl_idx,...]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * e.g. `df.loc[pd.IndexSlice[:,2nd_lvl_idx,...], &lt;slicing for column&gt;]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * *Datacamp loves to create the alias `idx=pd.IndexSlice` to shorten the .loc call.*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * MultiIndexes: the index is an array instead of a single value (think of nested arrays. e.g. arr[1][2], MultiIndex would be (1,2) or something)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **By Datetime** (if index is datetime): `ts0.loc[&#x27;2010-August&#x27;:&#x27;2010-10-11 22:00:00&#x27;]` </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * *can even be like &#x27;2010-Aug&#x27;*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * (See more: https://www.w3resource.com/pandas/dataframe/dataframe-loc.php)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * slicing refers to x[start:end:step].</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * Special slices:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * [:] =&gt; Select all</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * [n:] =&gt; from the nth element (inclusive) to the end; note that n starts from 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * [:n] =&gt; from the first element to the nth element</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Conditional Select</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Get by bool arr**: `df[bool_arr]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Get**: `dataframe[dataframe[&quot;column&quot;] == condition]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Assignment:** `df.loc[df[&#x27;col&#x27;] &lt;condition&gt;, &#x27;column_to_set&#x27;] = value_to_assign`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Multiple conditional**: `(df[&#x27;col&#x27;] == condition) &amp; (df[&#x27;col&#x27;] == condition)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* `dataframe[&quot;col&quot;] = dataframe[&#x27;col&#x27;] == condition`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **By data type**: `df.select_dtypes(include=[int, float])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Get data as datetime**: `df[&#x27;col&#x27;].dt`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Format datetime**: `df[&#x27;col&#x27;].dt.strftime(&#x27;formatstr&#x27;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * formatstr: e.g. &#x27;%Y&#x27; to only get the year</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Get data as str**: `df[&#x27;col&#x27;] = df[&#x27;col&#x27;].str`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* *This can be combined by concatenating string functions behind e.g. .lower(), .strip(), .upper(), .replace(dict), .replace(&quot;old&quot;,&quot;new&quot;), .len()*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Other fun obscure string functions include .startswith()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Chains must be prefixed with a `.str` in front e.g. `.str.replace(&#x27;x&#x27;,&#x27;&#x27;).str.replace(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* *Note that these string functions return a df, which can be combined with other str or aggregation functions*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Word count**: `df[&#x27;col&#x27;].str.split().str.len()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Data Addition</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* New Column:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Add new value**: `df.loc[lbl, col] = val` (do this for every row to add the column)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Set column to that value for every row**: `df[&#x27;col&#x27;] = val`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Modify by transformation function**: `df[&quot;newCol&quot;] = df[&quot;oldCol&quot;].apply(transformFx)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * e.g. `df.apply(lambda row: row.mean(), axis=1)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Regex can also be used etc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Modify by mapping values to a dictionary**: `df[&#x27;col&#x27;].map(dict_map_vals)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* New Row:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Append dataframe**: </span></div></div></div></div></div><p>  df1.append(df2,
ignore_index=False | True # False: Preserve index. True: Number everything from 0 to n
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Concatenating / Joining list of series/dataframes**: </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Plus** (if indexes are properly set): `df1 + df2`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Concat**</span></div></div></div></div></div><p>  pd.concat(list_of_dataframes, # Concatenating a dictionary will result in the keys becoming the indexes
axis=&#x27;index&#x27; | &#x27;columns&#x27;, # &#x27;index&#x27;: Stack below (&quot;vertically&quot;), &#x27;columns&#x27;: Stack to the right (&quot;horizontally&quot;)
keys=[&#x27;one&#x27;,&#x27;col&#x27;,&#x27;name&#x27;,&#x27;per&#x27;,&#x27;dataframe&#x27;,&#x27;in&#x27;,&#x27;list&#x27;],
join=&#x27;inner&#x27;,     # optional, keep only rows that share common index labels.
ignore_index=bool # If True, prevents repeated integer indices
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Keys: 1 key per DataFrame in the list, forming the outer index in the MultiIndex. The resulting DataFrame will be something like df[&#x27;one&#x27;][n] to access the first DataFrame, df[&#x27;col&#x27;][n] to access the 2nd DataFrame etc.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Merge / Join**</span></div></div></div></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="inner-join-equivalent-to-pdconcatleftdf-rightdf-columns-joininner"></a>Inner join, Equivalent to pd.concat([leftDF, rightDF], &#x27;columns&#x27;, join=&#x27;inner&#x27;)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#inner-join-equivalent-to-pdconcatleftdf-rightdf-columns-joininner" title="Direct link to heading">#</a></h1><p>  pd.merge(leftDF, rightDF,
on=column_label, # See exposition below
how=&#x27;inner&#x27;,     # Type of join. See below
suffixes=[sfx_forDF1, sfx_forDF2] # If both DFs have columns of same name, add suffix at the end if not merging on those columns
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **on:** If multiple columns form the identifier: use `on=[col1,col2,...]`. Otherwise, the join will horizontally append copies of the columns even if they are the same.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **on:** If df1 and df2 use different labels for the same identifier, use `left_on` and `right_on`.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **how:** You can also define various types of joins as specified [here](https://mode.com/sql-tutorial/sql-outer-joins/) </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* See [documentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html) if need to be more specific</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Ordered merge**</span></div></div></div></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="same-as-pdmerge-above-but-designed-for-ordered-data-like-time-series-and-filling-and-interpolation"></a>Same as pd.merge above, but designed for ordered data like time series and filling and interpolation.<a aria-hidden="true" tabindex="-1" class="hash-link" href="#same-as-pdmerge-above-but-designed-for-ordered-data-like-time-series-and-filling-and-interpolation" title="Direct link to heading">#</a></h1><p>  pd.merge_ordered(leftDF, rightDF,
fill_method=&quot;ffill&quot; # Forward-filling: Replace NaN entries with the most recent non-null entry,</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Other params same as above)</span></div></div></div></div></div><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Merge with value comparison**</span></div></div></div></div></div><p>  pd.merge_asof(...)</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="pdmerge_asof-is-like-the-pdmerge_ordered-function-it-merges-values-in-order-using-the-on-column"></a>pd.merge_asof() is like the pd.merge_ordered() function; it merges values in order using the on column<a aria-hidden="true" tabindex="-1" class="hash-link" href="#pdmerge_asof-is-like-the-pdmerge_ordered-function-it-merges-values-in-order-using-the-on-column" title="Direct link to heading">#</a></h1><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="but-for-each-row-in-the-left-dataframe-only-rows-from-the-right-dataframe-whose-on-column-values-are-less-than-the-left-value-will-be-kept"></a>but for each row in the left DataFrame, only rows from the right DataFrame whose &#x27;on&#x27; column values are less than the left value will be kept.<a aria-hidden="true" tabindex="-1" class="hash-link" href="#but-for-each-row-in-the-left-dataframe-only-rows-from-the-right-dataframe-whose-on-column-values-are-less-than-the-left-value-will-be-kept" title="Direct link to heading">#</a></h1><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Data Deletion</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Drop rows / columns**: </span></div></div></div></div></div><p>df.drop(labels,               # Index or column labels to drop.
axis= &#x27;index&#x27; | &#x27;columns&#x27;
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Drop rows / columns with missing values**: </span></div></div></div></div></div><p>df.dropna(
subset = [column_labels]    # Labels along other axis to consider, e.g. if you are dropping rows these would be a list of columns to include.
how = &#x27;any&#x27; | &#x27;all&#x27;         # &#x27;any&#x27; : If any NA values are present, drop that row or column. </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">                            # &#x27;all&#x27; : If all values are NA, drop that row or column.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">thresh = n                  # Drop unless there are at least n non-NA values along that axis</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">axis = &#x27;index&#x27; | &#x27;columns&#x27;  # 0/â€˜indexâ€™   : Drop rows    which contain missing values. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                            # 1/â€˜columnsâ€™ : Drop columns which contain missing values.</span></div></div></div></div></div><p>)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * See [documentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Drop duplicate rows**: </span></div></div></div></div></div><p>df.drop_duplicates(
subset = arr_of_col_names,
keep = &#x27;first&#x27; | &#x27;last&#x27; | False,
inplace = bool
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Value Modification</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Dividing one DF by another**:</span></div></div></div></div></div><p>  DF1.divide(DF2,
axis=&#x27;rows&#x27;/&#x27;columns&#x27; # Divide the DF1 by DF2 along each row
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Metadata modification</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Re-labelling columns**: `df.columns = arr_of_labels`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Datatype modification</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Convert to datetime**: </span></div></div></div></div></div><p>pd.to_datetime(df[&#x27;col&#x27;],
format = date_str_format,
infer_datetime_format = True | False,  # Infer format based on first non-NaN element. Can increase parsing speed by 5-10x (disabled by default)
errors = &#x27;raise&#x27; | &#x27;coerce&#x27; | &#x27;ignore&#x27; # raise = raise exception, coerce = set to NaT (not a time), ignore = ignore
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* A datetime column will allow you to manipulate the datetime directly &amp; search for rows that match the date using df.loc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * You can also extract information from it using its attributes. See any attr under [pandas.Series.dt](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.dt.month.html).</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * **Adding a new column for min/year etc**: `df[&quot;month&quot;] = df[&quot;date&quot;].apply(lambda row: row.month)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Example of merging 2 string cols into 1 datetime: `times_tz_none = pd.to_datetime(la[&#x27;Date (MM/DD/YYYY)&#x27;] + &#x27; &#x27; + la[&#x27;Wheels-off Time&#x27;])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Convert to numeric**: `pd.to_numeric(df[&#x27;col&#x27;], errors=&#x27;coerce&#x27;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Convert to categorical**: </span></div></div></div></div></div><p>df[&#x27;col&#x27;] = pd.Categorical(values=df[&#x27;col&#x27;], categories=arr_of_values,
ordered=True # True: ordered categoricals
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Bin values into discrete intervals (Convert numbers to categories)**: </span></div></div></div></div></div><p>df[&#x27;col&#x27;] = pd.cut(df[&#x27;col&#x27;],
bins = arr_of_bin_edges,    # e.g. [0, 60, 180, np.inf]
labels = arr_of_categories  # e.g. [&#x27;short&#x27;, &#x27;medium&#x27;, &#x27;long&#x27;]
)</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="alternatively-if-you-just-want-to-cut-them-into-equal-sized-bins"></a>Alternatively, if you just want to cut them into equal sized bins<a aria-hidden="true" tabindex="-1" class="hash-link" href="#alternatively-if-you-just-want-to-cut-them-into-equal-sized-bins" title="Direct link to heading">#</a></h1><p>df[&#x27;col&#x27;] = pd.cut(df[&#x27;col&#x27;],
bins = bin_counts
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Convert to other types**: `df[&#x27;newCol&#x27;] = df[&#x27;dataCol&#x27;].astype(&#x27;type&#x27;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Datetime timezone modification</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Localizing timezone**: `series.dt.tz_localize(&quot;US/Central&quot;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Converting timezone**: `series.dt.tz_convert(&quot;US/Central&quot;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Operations that involve boolean arrays:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Operations that convert DF into boolean DF:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Value meets condition**: `df_bool_arr = df[&#x27;col&#x27;] &gt; val`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Value membership**: `df[&#x27;col&#x27;].isin(arr_of_acceptable_values)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Value is null or NA**: `df.isnull()` or `df.isna()` (they are the same)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Value is not null**: `df.notnull()` or `df.notna()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Row is duplicated**: `df.duplicated(subset = arr_of_col_names, keep = &#x27;first&#x27; | &#x27;last&#x27; | False)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Negate boolean array**: `~bool_arr`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Subsetting with bool array**: `df[bool_df]`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Unary Operations</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Compute % change from the immediate previous**: `series.pct_change(offset=1)`: </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Row by default. Useful in comparing the percentage of change in a time series of elements. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Offset is in unit time specified in sample</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Grouping Data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Downsample time series**: `df[&#x27;col&#x27;].resample(time_str_format).agg_fx()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * e.g. `df.Temperature.resample(&#x27;6h&#x27;).mean()` = group an hourly based time series into averaged quarterly data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `df.resample(&#x27;A&#x27;).mean()`: resample w/ annual frequency, assumes index is a datetime</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `df.resample(&#x27;A&#x27;, on=column_label).mean()`: resample w.r.t a column label that isn&#x27;t the index</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* `groupby` function:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Group-by (Single index)**: `df.groupby(&#x27;idx&#x27;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Group-by (Multi-Index)**: `df.groupby([indexes])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Group-by (Rows)**: `df.groupby(pd.Series([&#x27;row_vals&#x27;])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Note that the groupby function should be followed up with a column + aggregate for it to be useful, unless you want to literally count the number of rows etc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * e.g. count_by_class = by_class[&#x27;survived&#x27;].count()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Group by Day example: `by_day = sales.groupby(sales.index.strftime(&#x27;%a&#x27;))`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Multiple Aggregation (columns)**: `sales.groupby(&#x27;city&#x27;)[[&#x27;bread&#x27;,&#x27;butter&#x27;]].max()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * ![](../../static/img/groupby-max.jpg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Multiple aggregation (functions)**: `sales.groupby(&#x27;city&#x27;)[[&#x27;bread&#x27;,&#x27;butter&#x27;]].agg([&#x27;max&#x27;,&#x27;sum&#x27;])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * ![](../../static/img/groupby-max-sum.jpg)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * **Custom aggregation (own function)**: You can define a function that accepts a Series and returns a single value.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * **Separate aggregation per column (dictionary)**: You can define a dictionary and put it into .agg; the key is the column, the value is the aggregation function (e.g. max, min)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `df.groupby(...).transform(fx)`: Transform after aggregation (group by, then transform values based on their groups)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * Output is the same shape as before groupby.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * e.g. `def zscore(series): return (series - series.mean()) / series.std()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * Usage: `df.groupby(&#x27;x&#x27;)[&#x27;y&#x27;].transform(zscore)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Filtering (after groupby)**:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `by_company = sales.groupby(&quot;Company&quot;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Compute sum of &#x27;Units&#x27;**: `by_com_sum = sales[&#x27;Units&#x27;].sum()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Filter &#x27;Units&#x27; where sum &gt; 35**: `by_com_filt = by_company.filter(lambda g:g[&#x27;Units&#x27;].sum() &gt; 35)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Aggregation Operations</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Get Uniques**: `series.unique()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Aggregate duplicates**: `df.groupby(by = arr_of_col_names).agg(col_to_fx_dict).reset_index()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * *col_to_fx_dict*: e.g. {&#x27;height: &#x27;max&#x27;, &#x27;weight&#x27;: mean}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **sum**: `df[&#x27;col&#x27;].sum(axis={index (0), columns (1)})`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * *You can also sum booleans to count number of True values*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Count number of missing values by col**: `df.isna().sum()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **mean**: `df[&#x27;col&#x27;].mean()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **max**: `df[&#x27;col&#x27;].max()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **argmax** (idx of max val): `df[&#x27;col&#x27;].argmax()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **count**: `df[&#x27;col&#x27;].count()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **quantile**: `quantile([start, end (0-1)])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Get single value: `quantile(pct_from_0_to_1)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **std.dev**: `std()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **rolling mean**: `df[&#x27;col&#x27;].rolling(window=numRows).mean()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **# of uniques:** `nunique()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Count number of times value appeared**: `value_counts()` / `series.value_counts()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Returns dataframe (dictionary)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Sorting Operations</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Sort by current index**: `df.sort_index(level=idx_lvl)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * You may want to change the index by using `df.set_index()` first</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Sort values by column name**: `df.sort_values(by = arr_of_col_names)` or `df.sort_values(&#x27;col&#x27;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Sort df chosen by boolean array**: `df[bool_arr].sort_values(...)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Windowing Operations</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* [Documentation](https://pandas.pydata.org/pandas-docs/stable/user_guide/computation.html)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* `df.expanding()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * See [this](https://stackoverflow.com/questions/45370666/what-are-pandas-expanding-window-functions): &quot;A common alternative to rolling statistics is to use an expanding window, which yields the value of the statistic with all the data available up to that point in time&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Operations on Indexes:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Interpolate**: `ts2_interp = ts2.reindex(ts1.index).interpolate(how=&#x27;linear&#x27;) `</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * in the above example, the index is changed to datetime. ts1 contains all datetime, ts2 has some missing data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Changing metadata / restructuring**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Reindex** (Change values of the 1st column): `df = df.reindex(col/df2.index,[method=pad/backfill/nearest])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * *Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index. A new object is produced unless the new index is equivalent to the current one and copy=False*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Change index entirely**: `df.set_index(&#x27;colname&#x27;,inplace=bool)`. </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * This is usually done as an interim operation to make naivgating the DF easier, or for using `sort_index()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * [Reindex vs set_index](https://stackoverflow.com/questions/50741330/difference-between-df-reindex-and-df-set-index-methods-in-pandas)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Reset index**: `df.reset_index()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Operations on Restructuring Data (Pivoting)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Pivot (reorder data by changing the index, columns &amp; values. REQUIRES UNIQUE INDEX)**: </span></div></div></div></div></div><p>df.pivot(
index=new_row_index,      # Each unique value in the column is now a primary key of the row. Aggfunc aggregates if there are duplicate PKs.
columns=new_columns,      # Each unique value in the column is now a column
values=old_cols_to_vals   # Each value in the column are now assigned to row-column where they occur. Aggregate if needed.
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Pivot Table: Same as pivot, but deal with duplicate index values with a reduction using aggfunc**:</span></div></div></div></div></div><p>df.pivot_table(
index=new_row_index,        # Each unique value in the column is now a primary key of the row. Aggfunc aggregates if there are duplicate PKs.
columns=new_columns,        # Each unique value in the column is now a column
values=old_cols_to_vals     # Each value in the column are now assigned to row-column where they occur. Aggregate if needed.
aggfunc=fx/&#x27;predefined_fx&#x27;, # Aggregate duplicate index values using this function
margins=bool                # If True, add a &quot;All&quot; row at the bottom which aggregates all data
)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Melt: undoing a pivot**: </span></div></div></div></div></div><p>pd.melt(dataframe,
id_vars=[&#x27;cols&#x27;],               # column names to keep as columns
value_vars=[&#x27;cols&#x27;],            # column names to convert into key-value pairs, under two columns: </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                # 1st column specified as &quot;variable&quot; which uses the original column name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">value_name=[&#x27;value_col_names&#x27;], # 2nd column whose name is specified by value_name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">col_level = 0                   # use col_level = 0 to convert it into purely variable-value pair, removing any id_vars / indexes currently in use</span></div></div></div></div></div><p>)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * [documentation](https://pandas.pydata.org/docs/reference/api/pandas.melt.html)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Stack**: `df.stack(level=&#x27;col&#x27;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * [stack the prescribed level(s) by shifting columns to index](https://www.w3resource.com/pandas/dataframe/dataframe-stack.php)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Unstacking**: `df.unstack(level=&#x27;col&#x27;/num)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * [form new level of columns whose inner-most level consists of the pivoted index labels](https://www.w3resource.com/pandas/dataframe/dataframe-unstack.php)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Swap level**: [swap ordering of stacked levels](https://www.geeksforgeeks.org/python-pandas-multiindex-swaplevel/)</span></div></div></div></div></div><p>dataframe.swaplevel(
index1_level, # e.g. 0 for the outer-most level
index2_level, # e.g. 1 for the inner level
axis=&#x27;index&#x27;|&#x27;columns&#x27;)</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">*  Operations involving missing values and cleaning data:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* **Impute/Replace missing vals**: `df.fillna({&#x27;col&#x27; : val_arr}, inplace=True)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * See [documentation](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html?highlight=fillna#pandas.DataFrame.fillna)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Operations involving visualization </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* DataFrame Info</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Correlation between columns**: `df.corr()`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * Correlation of A and B = Correlation of B and A</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Display head**: `df.head(&lt;rows=5&gt;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Display tail**: `df.tail(&lt;rows=5&gt;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Display schema**: `df.info()` (Shows col name, non-null entries &amp; datatype)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * **Display columns**: `df.columns`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Display summary stats (e.g. std,min,max,quartiles)**: `df.describe()` (also works on columns of the df)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Display datatype**: `df.dtype` or `df.dtypes` (works on columns of the df)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * **Size / Length / Shape**: `df.shape`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">* Plotting data from DataFrame (See matplotlib.pyplot):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `dataframe.plot(kind=&#x27;scatter&#x27;, x=&#x27;col1&#x27;, y=&#x27;col2&#x27;, [color=&#x27;str&#x27;, s=size_value,subplots=bool])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * you can plot all data by omitting x and y</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * subplots: plot in separate graphs</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `dataframe.boxplot(column = [y_axis_col_values], by=[x_axis_col_values])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * `ax = df[list_of_columns].plot() `</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * You can customize the plot by calling the functions below on ax:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * `ax.set_ylabel(&quot;% Change of Host Country Medal Count&quot;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * `ax.set_title(&quot;Is there a Host Country Advantage?&quot;)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * `ax.set_xticklabels(editions[&#x27;City&#x27;])`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * plot all of the columns (their x and y) on the same graph with their own colours</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * plt.title(str)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * plt.xlabel(str)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * plt.ylabel(str)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * plt.show()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * Subplots</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `fig, axes = plt.subplots(nrows=num_of_rows, ncols=num_of_columns)`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `df.plot(ax=axes[0], kind=&#x27;hist&#x27;, normed=True, bins=30, range=(0,.3))`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    * `df.fraction.plot(ax=axes[1], kind=&#x27;hist&#x27;, normed=True, cumulative=True, bins=30, range=(0,.3))`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      * `kind=&#x27;bar&#x27;`</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div></div></div></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/crazoter/My-Docs/edit/main/docs/markdown/python.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/My-Docs/docs/markdown/CS4268"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« CS4268 Quantum Computing</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/My-Docs/docs/markdown/math"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Math Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#project-setup" class="table-of-contents__link">Project setup</a></li><li><a href="#pure-python" class="table-of-contents__link">Pure Python</a></li><li><a href="#libraries--modules" class="table-of-contents__link">Libraries / Modules</a><ul><li><a href="#regex" class="table-of-contents__link">Regex</a></li><li><a href="#recordlinkage-join-datasets-wo-common-uid" class="table-of-contents__link">Recordlinkage (Join datasets w/o common UID)</a></li><li><a href="#fuzzywuzzy-string-comparison" class="table-of-contents__link">fuzzywuzzy (String Comparison)</a></li><li><a href="#missingno-visualize-missing-data" class="table-of-contents__link">missingno (Visualize missing data)</a></li><li><a href="#scipystats-zscore" class="table-of-contents__link">scipy.stats (zscore)</a></li><li><a href="#textatistic-evaluate-word-readability" class="table-of-contents__link">Textatistic (Evaluate word readability)</a></li><li><a href="#spacy-tokenization-and-lemmatization" class="table-of-contents__link">spacy (tokenization and lemmatization)</a></li><li><a href="#matplotlibpyplot-graphs--images" class="table-of-contents__link">matplotlib.pyplot (Graphs &amp; Images)</a></li><li><a href="#seaborn-graphs" class="table-of-contents__link">Seaborn (Graphs)</a></li><li><a href="#scikit-learn" class="table-of-contents__link">scikit-learn</a></li></ul></li><li><a href="#verifying-model-accuracy" class="table-of-contents__link">Verifying model accuracy</a></li><li><a href="#hyperparam-tuning" class="table-of-contents__link">Hyperparam Tuning</a><ul><li><a href="#imputer-impute-missing-info" class="table-of-contents__link">Imputer (Impute missing info)</a></li></ul></li><li><a href="#numpy" class="table-of-contents__link">Numpy</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Links</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.linkedin.com/in/matthew-lee-6a8a8a70/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LinkedIn</a></li><li class="footer__item"><a href="https://crazoter.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Portfolio</a></li></ul></div></div><div class="text--center"><div>Copyright Â© 2021 Matt's Docs, crazoter. Built with Docusaurus.</div></div></div></footer></div>
<script src="/My-Docs/styles.b91a0882.js"></script>
<script src="/My-Docs/runtime~main.e11f927f.js"></script>
<script src="/My-Docs/main.8dcec96c.js"></script>
<script src="/My-Docs/1.59cfe348.js"></script>
<script src="/My-Docs/2.4d5607e9.js"></script>
<script src="/My-Docs/51.70720b25.js"></script>
<script src="/My-Docs/52.59cf3399.js"></script>
<script src="/My-Docs/935f2afb.33106336.js"></script>
<script src="/My-Docs/17896441.75674ef7.js"></script>
<script src="/My-Docs/991d0552.dcb30ccd.js"></script>
</body>
</html>
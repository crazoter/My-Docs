<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.66">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Python Cheatsheet | Matt&#x27;s Docs</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Python Cheatsheet | Matt&#x27;s Docs"><meta data-react-helmet="true" name="description" content="Legend:"><meta data-react-helmet="true" property="og:description" content="Legend:"><meta data-react-helmet="true" property="og:url" content="https://crazoter.github.io/My-Docs/docs/markdown/python"><link data-react-helmet="true" rel="shortcut icon" href="/My-Docs/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://crazoter.github.io/My-Docs/docs/markdown/python"><link rel="stylesheet" href="/My-Docs/styles.29e05ea2.css">
<link rel="preload" href="/My-Docs/styles.62689871.js" as="script">
<link rel="preload" href="/My-Docs/runtime~main.21cb3e4f.js" as="script">
<link rel="preload" href="/My-Docs/main.1c75f43c.js" as="script">
<link rel="preload" href="/My-Docs/1.011eff76.js" as="script">
<link rel="preload" href="/My-Docs/2.7c72e25e.js" as="script">
<link rel="preload" href="/My-Docs/41.c917d6eb.js" as="script">
<link rel="preload" href="/My-Docs/42.79c20655.js" as="script">
<link rel="preload" href="/My-Docs/935f2afb.f40ae8ff.js" as="script">
<link rel="preload" href="/My-Docs/17896441.d279275b.js" as="script">
<link rel="preload" href="/My-Docs/991d0552.298a56b7.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/My-Docs/"><img class="navbar__logo" src="/My-Docs/img/ibuki.png" alt="My Site Logo"><strong class="navbar__title">Matt&#x27;s Docs</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/My-Docs/docs/">Docs</a><a class="navbar__item navbar__link" href="/My-Docs/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/crazoter/My-Docs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/My-Docs/"><img class="navbar__logo" src="/My-Docs/img/ibuki.png" alt="My Site Logo"><strong class="navbar__title">Matt&#x27;s Docs</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/My-Docs/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/My-Docs/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/crazoter/My-Docs" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Docusaurus</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/docusaurus/usage">Usage</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/docusaurus/doc1">Style Guide</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/docusaurus/mdx">Powered by MDX</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">AI</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS4246_summary">CS4246 Cheatsheet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/ai_planning">AI Planning (CS4246, Reinforcement Learning)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/computer_vision">Computer Vision</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/machine_learning">Machine Learning</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Languages</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/My-Docs/docs/markdown/python">Python Cheatsheet</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Math</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/math">Math</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Networks</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/network">Network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/CS4226_summary">CS4226 Cheatsheet</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Software Development</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/formal_verification">Formal Verification</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Misc</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/">Tech lookup</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/markdown/code_snippets">Code Snippets</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Hobbies</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/manga_reviews">Manga Reviews</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/My-Docs/docs/book_summaries">Book Summaries</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Python Cheatsheet</h1></header><div class="markdown"><p>Legend:</p><ul><li>#: Number, used for differentiating variables</li><li>L#: List.</li><li>D#: Dictionary. </li><li>itr#: Iterable.</li><li>DF#: Dataframe</li><li>mltIdx#: MultiIndex</li><li>idx: Index</li><li>int#: Integer variable</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="pure-python"></a>Pure Python<a aria-hidden="true" tabindex="-1" class="hash-link" href="#pure-python" title="Direct link to heading">#</a></h2><ul><li>Exponentiation: val ** power</li><li>Type conversion: <em>type</em>(val), where <em>type</em> in {int, float, str, bool}</li><li>Iterables<ul><li><strong>Loop with Index</strong>: for idx, val in enumerate(itr)</li><li><strong>Generators (lazy loading iteration)</strong><ul><li>Creation: <ul><li><code>gen = iter(L / D / *range(i)*)</code></li><li><code>gen = (x for x in list)</code></li><li><code>gen = def fx(param): ... for x in param: yield x ...</code></li></ul></li><li>Use:    val = next(itr)</li></ul></li></ul></li><li>Lists<ul><li><strong>Init with List Comprehension</strong><ul><li>Format: <code>[ (value) for (var_name) in (iterable) if (predicate) ]</code><ul><li>e.g. [L[0] for elem in list]</li></ul></li></ul></li><li>List of tuples:<ul><li><strong>Convert L to L of indexed tuples:</strong><ul><li><code>enumerate(itr, start=int1) = [(int1,itr[0]), (int1+1,itr[0])...]</code></li></ul></li><li>Merge two lists into a list of tuples:<ul><li><code>zip(*L1*,*L2*)</code><ul><li>returns zipObject: [ (L1[0],L2[0]),  (L1[1],L2[1])... ]</li><li>Access zipObject contents: (*zipObj)</li></ul></li><li>Unzip: <code>zip(*zipObj)</code></li></ul></li></ul></li></ul></li><li>Dictionaries<ul><li><strong>Init with Dictionary Comprehension</strong><ul><li>Format: <code>{ (key : value) for (var_name) in (iterable) if (predicate) }</code><ul><li>e.g. {x : len(x) for x in list}</li></ul></li></ul></li><li><strong>Init from list of tuples</strong><ul><li><code>dict(zip(L1,L2))</code></li></ul></li></ul></li><li>Functions:<ul><li>Default params: x=default</li><li>Flexible list param: <code>f(*args)</code><ul><li>Usage: f(v1,v2,v3...)</li></ul></li><li>Flexible dict param: <code>f(**kwargs)</code><ul><li>Usage: f(k1=v1,k2=v2,k3=v3...)</li></ul></li><li>Multiple output: <ul><li>def fx(): return (x, y)</li><li>Multiple assignment:<ul><li>x,y = fx()</li></ul></li></ul></li><li>Global variables: <code>global varname</code></li><li>Nested functions:<ul><li>Variables &amp; params of external f() is accessible</li><li>The function itself can be returned</li><li>Modify variables from nested f(): <code>nonlocal varname</code></li></ul></li></ul></li><li>Functional Programming<ul><li><code>map((lambda a: (transformation)), L)</code></li><li><code>filter((lambda a: (predicate)), L)</code></li><li><code>reduce((lambda a,b: ...), L) = result</code><ul><li>Import: <code>from functools import reduce</code></li></ul></li><li>The lambda can be replaced with a concrete function</li></ul></li><li>Lambdas<ul><li><code>(lambda (params): (body))</code></li><li>e.g. (lambda a: a+1) â‰¡ def f(a): return a+1</li><li>No &quot;return&quot;</li><li>No multi-line</li></ul></li><li>Exception Handling<ul><li>try: ... </li><li>except: ... </li><li>raise <em>Error</em>(<em>msg</em>)<ul><li>Error = {ValueError, TypeError, YourOwnErrClass}</li></ul></li></ul></li><li>I/O<ul><li>Open file:<ul><li><code>with open(&#x27;filepath&#x27;) as file_var</code><ul><li><code>file_var.readline()</code>: returns None if empty</li></ul></li></ul></li><li>Get script directory:<ul><li><code>dir_path = os.path.dirname(os.path.realpath(__file__))</code></li></ul></li><li>Get path to file relative to script directory:<ul><li><code>local_file = os.path.join(dir_path, &#x27;path&#x27;, &#x27;to&#x27;, &#x27;local_file&#x27;)</code></li></ul></li></ul></li><li>Datetime<ul><li>Req: <code>import datetime as dt</code></li><li><code>dt.date.today()</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="libraries--modules"></a>Libraries / Modules<a aria-hidden="true" tabindex="-1" class="hash-link" href="#libraries--modules" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recordlinkage-join-datasets-wo-common-uid"></a>Recordlinkage (Join datasets w/o common UID)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recordlinkage-join-datasets-wo-common-uid" title="Direct link to heading">#</a></h3><ul><li><code>import recordlinkage</code></li><li>Purpose: <strong>Join different datasets when they don&#x27;t share a unique identifier.</strong> See <a href="https://recordlinkage.readthedocs.io/en/latest/ref-index.html" target="_blank" rel="noopener noreferrer">Documentation</a><ol><li><strong>Init an indexer</strong></li></ol><ul><li><code>idxr = recordlinkage.Index()</code></li></ul><ol start="2"><li>Blocking: only <strong>choose pairs of entries that have the same value under specified column</strong> (e.g. &quot;cuisine_type&quot;)</li></ol><ul><li><code>idxr.block(&quot;col_name&quot;)</code></li></ul><ol start="3"><li><strong>Generate said pairs of indexes</strong> which agree on the equal columns</li></ol><ul><li><code>mltIdx_pairs = idxr.index(df1, df2)</code><ul><li>Example pair: MultiIndex([(0,0),(0,1),(0,7),(1,0),(1,4)...])</li></ul></li></ul><ol start="4"><li><strong>Specify the columns to compare</strong> with a Compare object</li></ol><ul><li><code>comp = recordlinkage.Compare()</code><ul><li>Then, specify the columns to compare by:<ul><li><code>comp.exact(&#x27;col_nm_in_df1&#x27;, &#x27;col_nm_in_df2&#x27;, label=&#x27;new_lbl_in_new_df&#x27;)</code><ul><li>Entries must <strong>exact match</strong> in the columns</li><li>e.g. comp.exact(&#x27;city&#x27;, &#x27;city&#x27;, label=&#x27;city&#x27;)</li></ul></li><li><code>comp.string(&#x27;col_nm_in_df1&#x27;, &#x27;col_nm_in_df2&#x27;, label=&#x27;new_lbl_in_new_df&#x27;, threshold = dbl_frm_0-1)</code> (threshold usually 0.8)</li><li>Entries must be <strong>similar</strong> (in terms of string) in the columns</li></ul></li></ul></li></ul><ol start="5"><li>Apply the Compare object to <strong>get a dataframe highlighting potential matches</strong></li></ol><ul><li><code>df_pttl_mtchs = comp.compute(mltIdx_pairs, df1, df2)</code><ul><li>Structure of df_pttl_mtchs:<ul><li>Index / Col 0: mltIdx_pairs</li><li>Columns: columns used for comparison<ul><li>exact: 1 if equal else 0</li><li>string: 1 if threshold met, else 0</li></ul></li></ul></li></ul></li></ul><ol start="6"><li><strong>Filter matches</strong> from potential matches</li></ol><ul><li><code>df_mtchs = df_pttl_mtchs[df_pttl_mtchs.sum(axis=1) &gt;= 3]</code><ul><li>If the val == 1 then there&#x27;s a match on that column. This counts the number of matched columns, and filters by that.</li><li>In this case there were 3 columns so 3 was chosen</li></ul></li></ul><ol start="7"><li><strong>Select matched indexes</strong> for one of the DFs (in this case df2)<ul><li><code>idx_df2_mtched = df_mtchs.index.get_level_values(1)</code><ul><li>df_pttl_mtchs &amp; df_mtchs use a MultiIndex. </li><li>df_mtchs.index.get_level_values(0) = df1&#x27;s indexes, (1) = df2&#x27;s indexes</li></ul></li></ul></li><li><strong>From df2, remove entries that match df1&#x27;s entries</strong></li></ol><ul><li><code>df2_notInDf1 = df2[~df2.index.isin(idx_df2_mtched)]</code></li></ul><ol start="9"><li><strong>Join df1 and the new df2 entries</strong></li></ol><ul><li><code>df1.append(df2_notInDf1)</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="fuzzywuzzy-string-comparison"></a>fuzzywuzzy (String Comparison)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#fuzzywuzzy-string-comparison" title="Direct link to heading">#</a></h3><ul><li><strong>Import</strong>: <code>from fuzzywuzzy import process</code></li><li><strong>Test similarity:</strong> <code>process.extract(&#x27;target_word&#x27;, arr_of_candidate_words, length_of_arr)</code><ul><li>Returns array of tuples: <code>[(&#x27;candidate_word&#x27;, similarity_score), ...]</code><ul><li>similarity_score: from 0 - 100, 100 as perfect, 80 as close enough</li></ul></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="missingno-visualize-missing-data"></a>missingno (Visualize missing data)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#missingno-visualize-missing-data" title="Direct link to heading">#</a></h3><ul><li><code>import missingno as msno</code></li><li>msno.matrix(df_with_missingvals); plt.show()</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="scipystats-zscore"></a>scipy.stats (zscore)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#scipystats-zscore" title="Direct link to heading">#</a></h3><ul><li><code>from scipy.stats import zscore</code></li><li>calculate zscore values: <code>zscore(df[&#x27;col&#x27;])</code><ul><li>z-score is the number of standard deviations by which an observation is above the mean - so if it is negative, it means the observation is below the mean.</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="numpy"></a>Numpy<a aria-hidden="true" tabindex="-1" class="hash-link" href="#numpy" title="Direct link to heading">#</a></h2><ul><li><strong>Import</strong>: <code>import numpy as np</code></li><li><strong>Numpy Array</strong><ul><li>Creation<ul><li><strong>Create array</strong>: <code>np.array(list)</code></li></ul></li><li>Attributes<ul><li><strong>Shape</strong>: <code>np_list.shape</code></li></ul></li><li>Unary Operations<ul><li><strong>Transpose array</strong>: <code>np.transpose(list)</code></li></ul></li><li>Operation with scalar<ul><li><strong>Slicing 2D numpy array (get row / get col)</strong>: <code>np_2d[row,:]</code>, <code>np_2d[:,col]</code></li><li><strong>Mass multiplication</strong>: <code>np_list *= val</code></li><li><strong>Iterate 2D array as 1D</strong>: <code>for x in np.nditer(np_2d_arr)</code></li></ul></li><li>Operations involving two numpy arrays<ul><li><strong>Mass operation</strong>: <code>np_list3 = np_list1 / np_list2</code></li><li><strong>Union</strong>: <code>np.logical_and(arr1, arr2)</code></li><li><strong>Intersect</strong>: <code>np.logical_or(a1,a2)</code><strong>* Negation of numpy arr</strong>: <code>np.logical_not(a1,a2)</code></li></ul></li><li>Operations involving boolean arrays<ul><li><strong>Generate boolean array by applying condition to array</strong>: <code>bool_val = np_list &gt; val</code></li><li><strong>Subsetting with bool array</strong>: <code>np_list[bool_val]</code></li></ul></li><li>Aggregation Operations<ul><li><strong>Mean</strong>: <code>np.mean(np_list)</code></li><li><strong>Median</strong>: <code>np.median(np_list)</code></li><li><strong>Std Dev</strong>: <code>np.std(np_list)</code></li><li><strong>Correlation Coeff</strong>: <code>np.corrcef(np_list1, np_list2)</code></li></ul></li></ul></li><li><strong>Numpy Random</strong><ul><li><strong>Init with Seed</strong>: <code>np.random.seed(seed)</code></li><li><strong>Generate Float</strong> 0-1: <code> np.random.rand()</code></li><li><strong>Generate Integer</strong>: <code>np.random.randint(lowerIncl, upperExcl)</code></li></ul></li><li><strong>Definitions</strong><ul><li><strong>NaN</strong>: <code>np.nan</code></li></ul></li><li><strong>Operations</strong><ul><li><strong>Log10</strong>: <code>np.log10(nd_arr or dataframe)</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="pandas"></a>Pandas<a aria-hidden="true" tabindex="-1" class="hash-link" href="#pandas" title="Direct link to heading">#</a></h2><ul><li><p><strong>Import</strong>: <code>import pandas as pd</code></p></li><li><p><strong>Series</strong> (Pandas labelled list)</p><ul><li><strong>From list</strong>: <code>pd.Series(array, ..., index=arr)</code></li></ul></li><li><p><strong>DataFrame</strong> (Pandas labelled excel sheets / dictionaries)</p><ul><li><p><strong>Converting into DataFrame</strong></p><ul><li><p><strong>From Dictionary</strong>: <code>pd.DataFrame(dict)</code></p></li><li><p><strong>From CSV File</strong>: </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">dataframe = pd.read_csv(string_filename, [</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    index_col   = i, # Column to use as row labels of the df. Set to False to force pandas not to use the first column as the index, or to a col name if you want to use that col</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    chunksize   = n, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    header      = line_no_start_of_data, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    names       = new_col_labels_list, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    delimiter   = str, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    comment     = str_prefix, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    parse_dates = [date_col...]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">])</span></div></div></div></div></div><ul><li>Note that dataframes are iterables, so you can use &quot;next(iterable)&quot; on them (to get them in the chunksize)</li></ul></li></ul></li><li><p><strong>Converting from DataFrame</strong></p><ul><li><strong>To set</strong>: <code>set(df[&#x27;col&#x27;])</code></li></ul></li><li><p><strong>Accessing</strong>:</p><ul><li><strong>For Loop for each row</strong> (note that row is a dataframe / dictionary)<ul><li><code>for idx, row in df.iterrows(): ...</code></li></ul></li><li>Slicing<ul><li><strong>Get column as Series</strong>: <code>dataframe[&quot;column&quot;]</code><ul><li><strong>Convert series to numpy.ndarray</strong>: <code>series.values</code></li></ul></li><li><strong>Get column as Dataframe</strong>: <code>dataframe[[&quot;column&quot;,...]]</code><ul><li><strong>Dataframe as rows</strong>: <code>dataframe[startIdxIncl: endIdxExcl]</code></li></ul></li></ul></li><li>Array based selection<ul><li><strong>Select by label</strong>: <ul><li><code>dataframe.loc[label]</code> (transposed / series / numpy array)</li><li><code>dataframe.loc[[rowLbl1, rowLbl2..* .],[colLbl1, colLbl2...]]</code> (tabular / dataframe)</li><li><strong>Select by index</strong>: Replace loc with iloc<ul><li><code>df.iloc[&lt;slicing for row&gt;, &lt;slicing for column&gt;]</code></li></ul></li><li><strong>Select all rows by column</strong>: Replace label with &#x27;:&#x27; <ul><li><code>dataframe.loc[&lt;slicing for row&gt;, &lt;slicing for column&gt;]</code></li><li><code>dataframe.loc[:,col]</code> (Returns numpy array)</li><li><code>dataframe.loc[:,* [cols]]</code> (Returns Dataframe)</li></ul></li><li><strong>MultiIndexes</strong>: <code>df.loc[(top_lvl_idx,2nd_lvl_idx,...), &lt;slicing for column&gt;]</code><ul><li>e.g. <code>sales.loc[(&#x27;NY&#x27;,1),:], sales.loc[(slice(None),2),:]</code></li><li>MultiIndexes: the index is an array instead of a single value (think of nested arrays. e.g. arr[1][2], MultiIndex would be (1,2) or something)</li></ul></li><li><strong>By Datetime</strong> (if index is datetime): <code>ts0.loc[&#x27;2010-August&#x27;:&#x27;2010-10-11 22:00:00&#x27;]</code> <ul><li><em>can even be like &#x27;2010-Aug&#x27;</em></li></ul></li><li>(See more: <a href="https://www.w3resource.com/pandas/dataframe/dataframe-loc.php" target="_blank" rel="noopener noreferrer">https://www.w3resource.com/pandas/dataframe/dataframe-loc.php</a>)<ul><li>slicing refers to x[startðŸ”šstep].</li><li>Special slices:<ul><li>[:] =&gt; Select all</li><li>[n:] =&gt; from the nth element (inclusive) to the end; note that n starts from 0</li><li>[:n] =&gt; from the first element to the nth element</li></ul></li></ul></li></ul></li></ul></li><li>Conditional Select<ul><li><strong>Get</strong>: <code>dataframe**[dataframe[&quot;column&quot;] == condition]</code></li><li><strong>Assignment:</strong> <code>df**.loc[df[&#x27;col&#x27;] &lt;condition&gt;] = value_to_assign</code></li><li><strong>Multiple conditional</strong>: <code>(df[&#x27;col&#x27;] == condition) &amp; (df[&#x27;col&#x27;] == condition)</code></li><li><code>dataframe[&quot;col&quot;] = dataframe[&#x27;col&#x27;] == condition</code></li></ul></li><li><strong>Get data as datetime</strong>: df[&#x27;col&#x27;].dt<ul><li><strong>Format datetime</strong>: df[&#x27;col&#x27;].dt.strftime(&#x27;formatstr&#x27;)<ul><li>formatstr: e.g. &#x27;%Y&#x27; to only get the year</li></ul></li></ul></li><li><strong>Get data as str</strong>: df[&#x27;col&#x27;] = df[&#x27;col&#x27;].str<ul><li><em>This can be combined by concatenating string functions behind e.g. lower(), strip(), upper(), replace(dict), replace(&quot;old&quot;,&quot;new&quot;), len()</em></li><li><em>Note that these string functions return a df, which can be combined with other str or aggregation functions</em></li></ul></li></ul></li><li><p><strong>Modifying Data</strong>:</p><ul><li>New Column:<ul><li><strong>Add new value</strong>: <code>df.loc[lbl, col] = val</code> (do this for every row to add the column)</li><li><strong>Modify by transformation function</strong>: <code>df**[&quot;newCol&quot;] = df[&quot;oldCol&quot;].apply(transformFx)</code></li><li><strong>Modify by mapping values to a dictionary</strong>: <code>df[&#x27;col&#x27;].map(dict_map_vals)</code></li></ul></li><li>New Row:<ul><li><strong>Append</strong>: <code>df.append(df,ignore_index=bool)</code><ul><li><em>Ignore index: Preserve index (False) or Number everything from 0 to n (True)</em></li></ul></li><li><strong>Concatenating list of series/dataframes</strong>: <div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button tabindex="0" type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">pd.concat(list_of_dataframes, </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    axis=column_index,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    keys=[&#x27;one&#x27;,&#x27;col&#x27;,&#x27;name&#x27;,&#x27;per&#x27;,&#x27;dataframe&#x27;,&#x27;in&#x27;,&#x27;list&#x27;]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div></div></div><ul><li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html" target="_blank" rel="noopener noreferrer">axis{0/â€™indexâ€™, 1/â€™columnsâ€™}, default 0</a></li><li>Keys: 1 key per DataFrame in the list, forming the outer index in the MultiIndex. The resulting DataFrame will be something like df[&#x27;one&#x27;][n] to access the first DataFrame, df[&#x27;col&#x27;][n] to access the 2nd DataFrame etc.</li></ul></li></ul></li><li>Deletion:<ul><li><strong>Drop columns</strong>: <code>df.drop(arr_of_cols, axis=&#x27;columns&#x27;)</code></li></ul></li><li>Metadata:<ul><li>Column datatype conversion<ul><li><strong>Convert to datetime</strong>: <code>pd.to_datetime(df[&#x27;col&#x27;][,format=date_str_format,infer_datetime_format = &lt;True/* False&gt;,  errors = &lt;&#x27;raise&#x27;/&#x27;coerce&#x27;/&#x27;ignore&#x27;&gt;])</code><ul><li>A datetime column will allow you to manipulate the datetime directly &amp; search for rows that match the date using df.loc</li><li><em>infer_datetime_format = Infer format based on first non-NaN element. Can increase parsing speed by 5-10x (disabled by default)</em></li><li><em>errors: raise = raise exception, coerce = set to NaT, ignore = ignore</em></li><li>Example of merging 2 string cols into 1 datetime: <code>times_tz_none = pd.to_datetime( la[&#x27;Date (MM/DD/YYYY)&#x27;] + &#x27; &#x27; + la[&#x27;Wheels-off Time&#x27;]</code>)</li></ul></li><li><strong>Convert to numeric</strong>: <code>pd.to_numeric(df[&#x27;col&#x27;], errors=&#x27;coerce&#x27;)</code></li><li><strong>Convert to categorical</strong>: <code>df[&#x27;col&#x27;] = pd.Categorical(values=df[&#x27;col&#x27;], categories=arr_of_values, ordered=True)</code> <ul><li><em>Ordered: ordered / non-ordered categoricals</em></li></ul></li><li><strong>Convert numbers to categories</strong>: <code>df[&#x27;col&#x27;] = pd.cut(df[&#x27;col&#x27;], bins = arr_of_bin_edges, labels = arr_of_categories)</code><ul><li><em>arr_of_bin_edges: e.g. [0, 60, 180, np.inf]</em></li><li><em>arr_of_categories: e.g. [&#x27;short&#x27;, &#x27;medium&#x27;, &#x27;long&#x27;]</em></li></ul></li><li><strong>Convert to others</strong>: <code>df[&#x27;newCol&#x27;] = df[&#x27;dataCol&#x27;].astype(&#x27;type&#x27;)</code></li></ul></li></ul></li><li>Datetime<ul><li><strong>Localizing timezone</strong>: series.dt.tz_localize(&quot;US/Central&quot;)</li><li><strong>Converting timezone</strong>: series.dt.tz_convert(&quot;US/Central&quot;)</li></ul></li><li><strong>Re-labelling columns</strong>: df.columns = arr_of_labels</li></ul></li><li><p>Unary Operations</p><ul><li>Check / Get Membership<ul><li><strong>Check membership (returns boolean array)</strong>: <code>df[&#x27;col&#x27;].isin(arr_of_acceptable_values)</code></li><li><strong>Negate boolean array</strong>: <code>~bool_arr</code></li></ul></li><li><strong>Get duplicates as boolean array</strong>: <code>df.duplicated()</code><ul><li><em>default behavior</em>: <code>returns exact duplicates after the first occurence</code></li><li><em>syntax</em>: <code>df.duplicated([subset = arr_of_col_names, keep = &lt;&#x27;first&#x27; / &#x27;last&#x27; / False&gt;)</code><ul><li><em>keep values</em>: <code>first, last or all (false) duplicate values</code></li></ul></li></ul></li><li><strong>Drop duplicates</strong>: <code>df.drop_duplicates([([subset = arr_of_col_names, keep = &lt;&#x27;first&#x27; / &#x27;last&#x27; / False&gt;, inplace = bool)</code></li><li><strong>Get Uniques</strong>: <code>df.unique()</code></li><li><strong>Find missing values</strong>: <code>df.isna()</code><ul><li><em>returns bool arr with same dimensions</em></li></ul></li><li><strong>Compute % change from the immediate previous</strong>: <code>series.pct_change()</code>: <ul><li>Row by default. Useful in comparing the percentage of change in a time series of elements.</li></ul></li></ul></li><li><p>Grouping Data:</p><ul><li><strong>Downsample time series</strong>: <code>df[&#x27;col&#x27;].resample(time_str_format).agg_fx()</code></li><li>e.g. <code>df.Temperature.resample(&#x27;6h&#x27;).mean()</code> = group an hourly based time series into averaged quarterly data</li><li><code>groupby</code> function:<ul><li><strong>Group-by (Single index)</strong>: <code>df.groupby(&#x27;idx&#x27;)</code></li><li><strong>Group-by (Multi-Index)</strong>: <code>df.groupby([indexes])</code></li><li><strong>Group-by (Rows)</strong>: <code>df.groupby(pd.Series([&#x27;row_vals&#x27;])</code></li><li>Note that the groupby function should be followed up with a column + aggregate for it to be useful, unless you want to literally count the number of rows etc<ul><li>e.g. count_by_class = by_class[&#x27;survived&#x27;].count()</li></ul></li><li>Group by Day example: <code>by_day = sales.groupby(sales.index.strftime(&#x27;%a&#x27;))</code></li><li><strong>Multiple Aggregation (columns)</strong>: <code>sales.groupby(&#x27;city&#x27;)[[&#x27;bread&#x27;,&#x27;butter&#x27;]].max()</code><ul><li><img src="/My-Docs/assets/images/groupby-max-be4dcc64d1a8ebef95937a4e84b1f704.jpg"></li></ul></li><li><strong>Multiple aggregation (functions)</strong>: <code>sales.groupby(&#x27;city&#x27;)[[&#x27;bread&#x27;,&#x27;butter&#x27;]].agg([&#x27;max&#x27;,&#x27;sum&#x27;])</code><ul><li><img src="/My-Docs/assets/images/groupby-max-sum-33ff5f981a0bb408858c107e9f564bd4.jpg"></li><li><strong>Custom aggregation (own function)</strong>: You can define a function that accepts a Series and returns a single value.</li><li><strong>Separate aggregation per column (dictionary)</strong>: You can define a dictionary and put it into .agg; the key is the column, the value is the aggregation function (e.g. max, min)</li><li><code>df.groupby(...).transform(fx)</code>: Transform after aggregation (group by, then transform values based on their groups)<ul><li>Output is the same shape as before groupby.</li><li>e.g. `def zscore(series): return (series - series.mean()) / series.std()</li><li>Usage: <code>df.groupby(&#x27;x&#x27;)[&#x27;y&#x27;].transform(zscore)</code></li></ul></li></ul></li></ul></li><li><strong>Filtering (after groupby)</strong>:<ul><li><code>by_company = sales.groupby(&quot;Company&quot;)</code></li><li><strong>Compute sum of &#x27;Units&#x27;</strong>: <code>by_com_sum = sales[&#x27;Units&#x27;].sum()</code></li><li><strong>Filter &#x27;Units&#x27; where sum &gt; 35</strong>: <code>by_com_filt = by_company.filter(lambda g:g[&#x27;Units&#x27;].sum() &gt; 35)</code></li></ul></li></ul></li><li><p>Aggregation Operations</p><ul><li><strong>Aggregate duplicates</strong>: <code>df.groupby(by = arr_of_col_names).agg(col_to_fx_dict).reset_index()</code><ul><li><em>col_to_fx_dict</em>: e.g. {&#x27;height: &#x27;max&#x27;, &#x27;weight&#x27;: mean}</li></ul></li><li><strong>sum</strong>: <code>df[&#x27;col&#x27;].sum()</code> or <code>df[&#x27;col&#x27;].sum(axis=1)</code><ul><li><em>Include axis=1 in aggregate f(x)s if you want to sum multiple columns, but keep the rows</em></li><li><em>You can also sum booleans to count number of True values</em></li><li><strong>mean</strong>: <code>df[&#x27;col&#x27;].mean()</code></li><li><strong>count</strong>: <code>df[&#x27;col&#x27;].count()</code></li><li><strong>quantile</strong>: <code>quantile([start, end (0-1)])</code></li><li><strong>std.dev</strong>: <code>std()</code></li><li><strong>rolling mean</strong>: <code>df[&#x27;col&#x27;].rolling(window=numRows).mean()</code></li><li><strong># of uniques:</strong> <code>nunique()</code></li><li><strong>Count times value appeared</strong>: <code>value_counts()</code> / <code>series.value_counts()</code><ul><li>Returns dataframe (dictionary)</li></ul></li></ul></li></ul></li><li><p>Sorting Operations</p><ul><li><strong>Sort values by column name</strong>: <code>df.sort_values(by = arr_of_col_names)</code> or <code>df.sort_values(&#x27;col&#x27;)</code><ul><li><strong>Sort df chosen by boolean array</strong>: <code>df[duplicates_bool].sort_values(...)</code></li></ul></li><li><strong>Sort by index</strong>: <code>df.sort_index()</code></li></ul></li><li><p>Operations involving DataFrame and boolean array:</p><ul><li><strong>Get duplicate rows</strong>: <code>df[df.duplicated()]</code></li></ul></li><li><p>Operations involving indexes:</p><ul><li><strong>Interpolate</strong>: <code>ts2_interp = ts2.reindex(ts1.index).interpolate(how=&#x27;linear&#x27;) </code><ul><li>in the above example, the index is changed to datetime. ts1 contains all datetime, ts2 has some missing data</li></ul></li><li><strong>Changing metadata / restructuring</strong><ul><li><strong>Reindex</strong> (Change values of the 1st column): <code>df = df.reindex(col/df2.index,[method=pad/backfill/nearest])</code><ul><li><em>Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index. A new object is produced unless the new index is equivalent to the current one and copy=False</em></li></ul></li><li><strong>Change index entirely</strong>: <code>df.set_index(&#x27;colname&#x27;,inplace=bool)</code>. <ul><li><a href="https://stackoverflow.com/questions/50741330/difference-between-df-reindex-and-df-set-index-methods-in-pandas" target="_blank" rel="noopener noreferrer">Reindex vs set_index</a></li></ul></li><li><strong>Reset index</strong>: <code>df.reset_index()</code></li><li><strong>Rename columns</strong>: <code>df.columns = arr</code></li></ul></li></ul></li><li><p>MultiIndexes    </p><ul><li><strong>Pivot (reorder data by changing the index, columns &amp; values. REQUIRES UNIQUE INDEX)</strong>: <ul><li><code>df.pivot(index=new_row_index, columns=new_columns, values=old_cols_to_vals)</code></li><li><strong>Index</strong>: Each unique value in the column is now a primary key of the row. Aggfunc aggregates if there are duplicate PKs.</li><li><strong>Columns</strong>: Each unique value in the column is now a column.</li><li><strong>Values</strong>: Each value in the column are now assigned to row-column where they occur. Aggregate if needed. </li></ul></li><li><strong>Pivot Table: Same as pivot, but deal with duplicate index values with a reduction</strong>:</li><li><code>df.pivot_table(same_as_pivot,aggfunc=fx/&#x27;predefined_fx&#x27;, margins=bool)</code><ul><li><strong>margins</strong>: If True, add a &quot;All&quot; row at the bottom which aggregates all data</li></ul></li><li><strong>Melt: undoing a pivot</strong>: <code>pd.melt(df, id_vars=[&#x27;cols&#x27;], value_vars=[&#x27;cols&#x27;], value_name=&#x27;value_col_name&#x27;])</code><ul><li><strong>id_vars</strong>: column name to keep as columns</li><li><strong>value_vars</strong>: column names to convert into key-value pairs, under two columns: 1 column specified as &quot;variable&quot; which uses the original column name and the 2nd column whose name is specified by value_name</li><li>you can also use col_level = 0 to convert it into purely variable-value pair, removing any id_vars / indexes currently in use</li><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.melt.html" target="_blank" rel="noopener noreferrer">documentation</a></li></ul></li><li><strong>Stack</strong>: <code>df.stack(level=&#x27;col&#x27;)</code><ul><li><a href="https://www.w3resource.com/pandas/dataframe/dataframe-stack.php" target="_blank" rel="noopener noreferrer">stack the prescribed level(s) from columns to index</a></li></ul></li><li><strong>Unstacking</strong>: <code>df.unstack(level=&#x27;col&#x27;/num)</code><ul><li><a href="https://www.w3resource.com/pandas/dataframe/dataframe-unstack.php" target="_blank" rel="noopener noreferrer">form new level of column labels whose inner-most level consists of the pivoted index labels</a></li></ul></li><li><strong>Swap level</strong>: <code>df.swaplevel(0,1)</code> <ul><li><a href="https://www.geeksforgeeks.org/python-pandas-multiindex-swaplevel/" target="_blank" rel="noopener noreferrer">swap ordering of stacked levels</a></li></ul></li></ul></li><li><p>Operations involving two DataFrames:</p><ul><li><strong>Joining</strong> (with properly set indices): df1 + df2</li></ul></li><li><p>Operations involving missing values and cleaning data:</p><ul><li><strong>Drop rows/cols with missing values</strong>: <code>df.dropna(subset = [&#x27;col&#x27;])</code><ul><li>See <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html" target="_blank" rel="noopener noreferrer">documentation</a></li><li><strong>Drop rows that have a NA value in any col</strong>: <code>df.dropna(how=&#x27;any&#x27;)</code></li><li><strong>Drop rows that have all NA values</strong> : <code>df.dropna(how=&#x27;all&#x27;)</code></li><li><strong>Drop cols that have less than 1000 non-missing values</strong>: <code>df.dropna(thresh=1000, axis=&#x27;columns&#x27;)</code></li></ul></li><li><strong>Impute missing vals</strong>: <code>df.fillna({&#x27;col&#x27; : val_arr})</code><ul><li>See <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html?highlight=fillna#pandas.DataFrame.fillna" target="_blank" rel="noopener noreferrer">documentation</a></li></ul></li><li><strong>Count number of missing values by col</strong>: <code>df.isna().sum()</code></li></ul></li><li><p>Operations involving visualization</p><ul><li>DataFrame Info<ul><li><strong>Display head</strong>: <code>df.head(&lt;rows=5&gt;)</code></li><li><strong>Display tail</strong>: <code>df.tail(&lt;rows=5&gt;)</code></li><li><strong>Display schema</strong>: <code>df.info()</code> (Shows col name, non-null entries &amp; datatype)</li><li><strong>Display summary stats</strong>: <code>df.describe()</code> (also works on columns of the df)</li><li><strong>Display datatype</strong>: <code>df.dtype</code> or <code>df.dtypes</code> (works on columns of the df)</li><li><strong>Size / Length / Shape</strong>: <code>df.shape</code></li></ul></li><li>Plotting data from DataFrame:<ul><li><code>dataframe.plot(kind=&#x27;scatter&#x27;, x=&#x27;col1&#x27;, y=&#x27;col2&#x27;, [color=&#x27;str&#x27;, s=size_value,subplots=bool])</code><ul><li>you can plot all data by omitting x and y</li><li>subplots: plot in separate graphs</li></ul></li><li><code>df[list_of_columns].plot() </code><ul><li>plot all of the columns (their x and y) on the same graph with their own colours</li><li>plt.title(str)</li><li>plt.xlabel(str)</li><li>plt.ylabel(str)</li><li>plt.show()</li></ul></li><li>Subplots<ul><li><code>fig, axes = plt.subplots(nrows=num_of_rows, ncols=num_of_columns)</code></li><li><code>df.plot(ax=axes[0], kind=&#x27;hist&#x27;, normed=True, bins=30, range=(0,.3))</code></li><li><code>df.fraction.plot(ax=axes[1], kind=&#x27;hist&#x27;, normed=True, cumulative=True, bins=30, range=(0,.3))</code></li></ul></li></ul></li></ul></li></ul></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/crazoter/My-Docs/edit/master/website/docs/markdown/python.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/My-Docs/docs/markdown/machine_learning"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Machine Learning</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/My-Docs/docs/markdown/math"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Math Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#pure-python" class="table-of-contents__link">Pure Python</a></li><li><a href="#libraries--modules" class="table-of-contents__link">Libraries / Modules</a><ul><li><a href="#recordlinkage-join-datasets-wo-common-uid" class="table-of-contents__link">Recordlinkage (Join datasets w/o common UID)</a></li><li><a href="#fuzzywuzzy-string-comparison" class="table-of-contents__link">fuzzywuzzy (String Comparison)</a></li><li><a href="#missingno-visualize-missing-data" class="table-of-contents__link">missingno (Visualize missing data)</a></li><li><a href="#scipystats-zscore" class="table-of-contents__link">scipy.stats (zscore)</a></li></ul></li><li><a href="#numpy" class="table-of-contents__link">Numpy</a></li><li><a href="#pandas" class="table-of-contents__link">Pandas</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Links</h4><ul class="footer__items"><li class="footer__item"><a href="https://www.linkedin.com/in/matthew-lee-6a8a8a70/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LinkedIn</a></li><li class="footer__item"><a href="https://crazoter.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Portfolio</a></li></ul></div></div><div class="text--center"><div>Copyright Â© 2020 Matt's Docs, crazoter. Built with Docusaurus.</div></div></div></footer></div>
<script src="/My-Docs/styles.62689871.js"></script>
<script src="/My-Docs/runtime~main.21cb3e4f.js"></script>
<script src="/My-Docs/main.1c75f43c.js"></script>
<script src="/My-Docs/1.011eff76.js"></script>
<script src="/My-Docs/2.7c72e25e.js"></script>
<script src="/My-Docs/41.c917d6eb.js"></script>
<script src="/My-Docs/42.79c20655.js"></script>
<script src="/My-Docs/935f2afb.f40ae8ff.js"></script>
<script src="/My-Docs/17896441.d279275b.js"></script>
<script src="/My-Docs/991d0552.298a56b7.js"></script>
</body>
</html>